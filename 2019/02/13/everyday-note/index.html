<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">









  <meta name="baidu-site-verification" content="UfhqWeMiz6">



  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mina:300,300italic,400,400italic,700,700italic|Lato:300,300italic,400,400italic,700,700italic|Indie Flower:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32-xia.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16-xia.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="每天记点小笔记我也可以拿第一">
<meta name="keywords" content="C++,旅游,markdown,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://yoursite.com/2019/02/13/everyday-note/index.html">
<meta property="og:site_name" content="Xia&#39;s Blog">
<meta property="og:description" content="每天记点小笔记我也可以拿第一">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://db3pap006files.storage.live.com/y4mEnAGg44uYxfHrF0R8reacZSzAh9Y7L84UMSPMfSbtpsuMwcvP3Yfch82Avu9rbFpeoSUtg9MkLvAcEq-nrBueoA-FxWb_eIaRk3SMigjZAQL7OlvKm9ZtMIqUdmVyfns-vHLUF30bCsxi4kVBCaI5y2vTCkMs4kSzQKNslljLxAN4OmT8GWnARFX8zv16Xem?width=1218&height=892&cropmode=none">
<meta property="og:image" content="https://hbz5pg.db.files.1drv.com/y4mK1Cy61ASatue4EHdhjW2-ZGTNaoEIxjwwPLAMTtzv3Ja4dzuVyp8q63v6Ex9R6zJW-wgP5giM7gkWOamL6QIUiW-t661E255VP53nQTNxMelllRY8XFJ4_N3b5lSJdhnw7DmseQ4zT6wuAVMFhUwk4oaHPdV4Al4BPbhV1QzfhwmMNDHRsluyyRLmJnnKujBm8SemtYWb5so5p0fojNWPA?width=1104&height=832&cropmode=none">
<meta property="og:image" content="https://idghnq.db.files.1drv.com/y4mOVoNLgKDKgUpcvLDlIzqMtXRMHim2rBETwZ4yHnPtK7wp7G-s9JvUV-qmY8e3Q7oSXdJ7XKH1ZXRMV0YknNxifEGAVrF1J5Fw3UdscFvxPCHTJizqs27fu00YvRlaynYe49BlCnIvS7KGQJQJkoCHtTLoqW_xaaR701qV-LjmMb3ukNOJVEhBNVpUkk4yKdzUW1zBOrWx8jWX5inSXVlkw?width=1388&height=788&cropmode=none">
<meta property="og:image" content="https://hepsia.db.files.1drv.com/y4mx_T6o_-ZGHXj-IHnxItAQkNOSYQd7fkiu0oOAqejCTzMjO3AwIp4eE21yE8SKEJKYxfZQuQ3mmzVTRurPuXhp024cQNepuU2uXqFqh4qcOWrPj_d8dEuyjSvKp23yjMBX6MUCwKhJEy-kPghFS97LnPsztAZUCej0u_sN2iJrBOSyU2e8eBaD-D17PCl56Su1bQRI27aYpQHiYAPVRriRw?width=660&height=448&cropmode=none">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/positon-embedding-1.jpg">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/position-embedding-2.jpg">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/moving-average.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/debiasing.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/code-cost-longshort.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/calculating-entropy.JPG">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/cross-entropy.JPG">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/cross-entropy-unsymmetrical.JPG">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/simpson-separated-note.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/word-word-co-occurrence-matrix.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/attention.JPG">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/unlinear.JPG">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/unlinear1.JPG">
<meta property="og:image" content="http://yoursite.com/2019/02/13/everyday-note/Composition.JPG">
<meta property="og:updated_time" content="2022-04-29T04:39:04.558Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记本">
<meta name="twitter:description" content="每天记点小笔记我也可以拿第一">
<meta name="twitter:image" content="https://db3pap006files.storage.live.com/y4mEnAGg44uYxfHrF0R8reacZSzAh9Y7L84UMSPMfSbtpsuMwcvP3Yfch82Avu9rbFpeoSUtg9MkLvAcEq-nrBueoA-FxWb_eIaRk3SMigjZAQL7OlvKm9ZtMIqUdmVyfns-vHLUF30bCsxi4kVBCaI5y2vTCkMs4kSzQKNslljLxAN4OmT8GWnARFX8zv16Xem?width=1218&height=892&cropmode=none">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/02/13/everyday-note/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>笔记本 | Xia's Blog</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-142746162-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-142746162-1');
    }
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xia's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/everyday-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="欢乐一只虾">
      <meta itemprop="description" content="xia写的">
      <meta itemprop="image" content="https://ewa2xg.dm.files.1drv.com/y4mFMxhQ1DM81Jvak_RBJiGQ3w8LsLmDqb0ohVKkPYwEEraNIEfIiKXMg02UaLGvQErnG1rYTAIQeDIMzSmXnHjZ2UcGrK8wApxrjNxElJCL9BJOKRc9f-ciWgJJiML6e0UOtwWbNmlDOMjYq11-KUhdY9xXgnUqT2RcyElJoRIo0yuNmHDChUPkEcYBG_7BzrxyZIGr6pO2roys0Cg4n609w?width=1280&height=718&cropmode=none">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xia's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">笔记本

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-13 15:01:33" itemprop="dateCreated datePublished" datetime="2019-02-13T15:01:33+08:00">2019-02-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-04-29 12:39:04" itemprop="dateModified" datetime="2022-04-29T12:39:04+08:00">2022-04-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日常笔记/" itemprop="url" rel="index"><span itemprop="name">日常笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">73k</span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p>每天记点小笔记<br>我也可以拿第一</p>
<hr>
<a id="more"></a>
<h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="2022-01"><a href="#2022-01" class="headerlink" title="2022-01"></a>2022-01</h2><h3 id="2022-01-22"><a href="#2022-01-22" class="headerlink" title="2022-01-22"></a>2022-01-22</h3><ul>
<li><p>malloc、calloc、realloc、alloca</p>
<ul>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ul>
</li>
<li><p>new、delete</p>
<ul>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ul>
</li>
<li><p>如何定义一个只能在堆上（栈上）生成对象的类？</p>
<ul>
<li>只能在堆上<ul>
<li>方法：将析构函数设置为私有</li>
<li>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li>
</ul>
</li>
<li>只能在栈上<ul>
<li>方法：将 new 和 delete 重载为私有</li>
<li>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2022-01-05"><a href="#2022-01-05" class="headerlink" title="2022-01-05"></a>2022-01-05</h3><ul>
<li>LLVM, GCC, Clang<ul>
<li>GCC 是一整套，LLVM 是优化器+后端编译器，Clang是前端语法树解析器编译器</li>
<li>可以用 GCC 的前端 接 LLVM 的后端，但是 GCC 前端性能不及 Clang，GCC 优点是支持的语种多。</li>
</ul>
</li>
</ul>
<h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><h2 id="2021-09"><a href="#2021-09" class="headerlink" title="2021-09"></a>2021-09</h2><h2 id="2021-09-07"><a href="#2021-09-07" class="headerlink" title="2021-09-07"></a>2021-09-07</h2><ul>
<li>ssh 指定host的默认用户名在 .ssh/config 文件中指定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host my.hostname.com</span><br><span class="line">  User guoxia</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2021-08"><a href="#2021-08" class="headerlink" title="2021-08"></a>2021-08</h2><h3 id="2021-08-03"><a href="#2021-08-03" class="headerlink" title="2021-08-03"></a>2021-08-03</h3><ul>
<li><p>docker 套接字权限： sudo chmod a+rw /var/run/docker.sock</p>
</li>
<li><p>雅思听力语料库听写准确率：</p>
<ul>
<li>3-4: 83 / 112 = 73%</li>
<li>3-5：99 / 144 = 69%</li>
<li>3-6：86 / 112 = 77%</li>
<li>3-7: 81 / 104 = 78%</li>
<li>3-8: 98 / 152 = 64%</li>
<li>3-9: 93 / 144 = 65%</li>
</ul>
</li>
</ul>
<h3 id="2021-08-02"><a href="#2021-08-02" class="headerlink" title="2021-08-02"></a>2021-08-02</h3><ul>
<li>source code : examples<ul>
<li><code>char</code>, <code>short</code>, <code>int</code>, <code>long</code> 分别占多少空间？<ul>
<li>C/C++ 标准都没有硬性规定必须要多大，只规定了 <code>short</code> 至少 2 个字节，而且后者要比前者大就行，如果需要用到确切位数的变量，尽量用类似 <code>int16_t</code> 这些定义在 <code>stddef.h</code> 中的类型。</li>
</ul>
</li>
<li><code>size_t</code> 多大?<ul>
<li>和指针一样大，因为它要足够容纳系统中所有的地址。它是无符号类型的。</li>
</ul>
</li>
<li><code>char</code> 默认有符号还是无符号？<ul>
<li>不一定，如果确认自己要用有符号/无符号的 <code>char</code>，请明确声明。</li>
</ul>
</li>
<li><code>sizeof(&#39;a&#39;)</code> 输出多少？<ul>
<li>C 语言中没有字符量的概念，<code>&#39;a&#39;</code> 解释为一个 int，因此输出 4</li>
<li>C++ 中 <code>&#39;a&#39;</code> 解释为一个 char，因此输出 1</li>
</ul>
</li>
<li><code>malloc</code> 的参数类型是啥？如果传递一个负数给它会发生什么？<ul>
<li>参数类型是 <code>size_t</code>，如果传递是一个负数，会转换成一个很大的正数（因为负数的高位都是1）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2021-08-01"><a href="#2021-08-01" class="headerlink" title="2021-08-01"></a>2021-08-01</h3><ul>
<li>雅思听力语料库听写准确率：<ul>
<li>3-0: 218 / 358 = 61%</li>
<li>3-1: 76 / 112 = 68% </li>
<li>3-2: 95 / 156 = 61%</li>
<li>3-3：82 / 112 = 73%</li>
</ul>
</li>
</ul>
<h2 id="2021-07"><a href="#2021-07" class="headerlink" title="2021-07"></a>2021-07</h2><h3 id="2021-07-06"><a href="#2021-07-06" class="headerlink" title="2021-07-06"></a>2021-07-06</h3><ul>
<li>需要创造性的任务用 beam search 的效果不好。</li>
</ul>
<h2 id="2021-06"><a href="#2021-06" class="headerlink" title="2021-06"></a>2021-06</h2><h3 id="2021-06-17"><a href="#2021-06-17" class="headerlink" title="2021-06-17"></a>2021-06-17</h3><ul>
<li>C++ 容器：<ul>
<li>vector 通常保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。</li>
</ul>
</li>
</ul>
<h3 id="2021-06-10"><a href="#2021-06-10" class="headerlink" title="2021-06-10"></a>2021-06-10</h3><ul>
<li><p>多线程：</p>
<ul>
<li><p>传参给线程的过程都是先通过简单的拷贝，要注意一些问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> weight, WeightedData&amp; data)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_update</span><span class="params">(<span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">    WeightedData data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">wk_t</span><span class="params">(update, weight, data)</span></span>;     <span class="comment">// 首先吧 data 整个复制到线程，然后再把它传递给 update 的第二个参数。应该使用 std::ref(data)</span></span><br><span class="line">    t.join();</span><br><span class="line">    process(data);                              </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>unique_lock</code> 相比 <code>lock_guard</code> 的好处是：可以随时 unlock() 和 lock()</p>
</li>
</ul>
</li>
</ul>
<h3 id="2021-06-09"><a href="#2021-06-09" class="headerlink" title="2021-06-09"></a>2021-06-09</h3><ul>
<li>批量归一化：<ul>
<li>底层变了，后面层的参数就白训了，所以想让底层的参数的分布更稳定</li>
<li>作用在激活函数之前，全连接作用在特征维，卷积作用在通道维。</li>
<li>BN在做什么？<ul>
<li>最初论文是想用它来减少内部协变量转移</li>
<li>后续论文指出它可能是通过在每个小批量里加入了噪音来控制模型复杂度</li>
<li>因此没必要跟丢弃法混合使用</li>
</ul>
</li>
<li>一般可以加速收敛，允许使用更大的学习率。</li>
</ul>
</li>
</ul>
<h2 id="2021-05"><a href="#2021-05" class="headerlink" title="2021-05"></a>2021-05</h2><h3 id="2021-05-12"><a href="#2021-05-12" class="headerlink" title="2021-05-12"></a>2021-05-12</h3><ul>
<li>C++ object model:<ul>
<li><code>&amp; Point3d::z</code> 和 <code>&amp; p3d.z</code> 的区别。P132</li>
<li>目前现代的编译器好像 “指向 data members 的指针” 不会再被加 1 偏移（原来加一偏移是为了区分 0 指针和指向第一个 data member 的指针，现在都有各自的办法区分这两种情况，所以也就不需要这个偏移量了）。</li>
</ul>
</li>
</ul>
<h3 id="2021-05-11"><a href="#2021-05-11" class="headerlink" title="2021-05-11"></a>2021-05-11</h3><ul>
<li>C++ object model:<ul>
<li>C++ standard 要求，同一个 access section 中， 成员变量的排列只需符合 “较晚出现的 members 在 class object 中有较高的地址”这一条件即可。也就是说，并不一定要连续排列。P92</li>
<li>成员变量的存取<ul>
<li>静态成员 vs. 非静态</li>
<li>用指针访问 vs. 用对象名访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2021-05-10"><a href="#2021-05-10" class="headerlink" title="2021-05-10"></a>2021-05-10</h3><ul>
<li>C++ object model：<ul>
<li>C++ 新手一般有两个常见的误解。P47<ul>
<li>任何 class 如果没有定义 default constructor, 都会被合成一个出来。</li>
<li>编译器合成出来的 default constructor 会设定 “class 内每个 data member 的默认值”</li>
</ul>
</li>
<li>有三种情况，会以一个 object 的内容作为另一个 object 的初值。<ul>
<li>赋值</li>
<li>传参</li>
<li>返回值</li>
</ul>
</li>
<li>和 default constructor 类似，copy constructor 也是在必要的时候才由编译器产生出来。</li>
<li>不属于 bitwise copy semantics 的情况：<ul>
<li>基类或成员类里有一个 copy constructor</li>
<li>自身有一个或多个虚函数，或有虚基类。</li>
</ul>
</li>
<li>程序转化语义学。P60</li>
</ul>
</li>
</ul>
<h3 id="2021-05-08"><a href="#2021-05-08" class="headerlink" title="2021-05-08"></a>2021-05-08</h3><ul>
<li>C++ object model:<ul>
<li>一个 class object 需要多少内存？P27</li>
<li>当编译器需要的时候（而不是程序需要），才会合成一个 default constructor。P40</li>
<li>编译器需要 default constructor 的4种情况。P41</li>
<li>全局对象会在程序启动的时候被清为0，分配在堆栈和堆中的局部变量初始不一定会是0，一般是上次内存被使用后的遗迹。P40</li>
</ul>
</li>
</ul>
<h2 id="2021-04"><a href="#2021-04" class="headerlink" title="2021-04"></a>2021-04</h2><h3 id="2021-04-23"><a href="#2021-04-23" class="headerlink" title="2021-04-23"></a>2021-04-23</h3><ul>
<li>C++<ul>
<li>取虚函数表的地址：<code>(int*)(&amp;Obj)</code></li>
<li>虚函数表的第一个函数地址: <code>(int*) * (int*)(&amp;dObj)</code></li>
<li>以上假设是建立在：虚函数指针放在对象的起始位置，虽然目前大多数编译器都是这么干的，但是其实C++标准没有规定，所以对于有些编译器可能还是会有问题。</li>
</ul>
</li>
</ul>
<h3 id="2021-04-08"><a href="#2021-04-08" class="headerlink" title="2021-04-08"></a>2021-04-08</h3><ul>
<li>C++<ul>
<li>const 和 constexpr 有什么联系和区别？<ul>
<li>本质上，const 用来表示一个运行时常量。在 C++ 里，const 后面渐渐带上了现在的 constexpr 用法，也代表编译期常数。现在——在有了 constexpr 之后——我们应该使用 constexpr 在这些用法中替换 const 了。从编译器的角度，为了向后兼容性，const 和 constexpr 在很多情况下还是等价的。但有时候，它们也有些细微的区别。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2021-04-07"><a href="#2021-04-07" class="headerlink" title="2021-04-07"></a>2021-04-07</h3><ul>
<li><p>自修：</p>
<ul>
<li>C/C++ 程序为什么要有堆？（P305）<ul>
<li>栈上的数据在函数返回的时候会被释放掉，所以无法传递到函数外部</li>
<li>全局变量没有办法动态产生，只能在编译的时候定义，缺乏灵活性</li>
</ul>
</li>
<li>堆内存由谁管理？<ul>
<li>运行库：它向操作系统“进货”，然后“零售”给程序使用。它有一套分配算法来管理堆空间。</li>
</ul>
</li>
<li>malloc 申请的空间是不是连续的？<ul>
<li>虚拟空间是连续的；物理空间不一定连续（P311）</li>
</ul>
</li>
</ul>
</li>
<li><p>算法：</p>
<ul>
<li>LRU cache</li>
</ul>
</li>
</ul>
<h2 id="2021-03"><a href="#2021-03" class="headerlink" title="2021-03"></a>2021-03</h2><h3 id="2021-03-31"><a href="#2021-03-31" class="headerlink" title="2021-03-31"></a>2021-03-31</h3><ul>
<li>自修：<ul>
<li>两步链接<ul>
<li>第一步 空间与地址分配</li>
<li>第二部 符号解析与重定位</li>
</ul>
</li>
<li>为什么静态运行库里面一个目标文件只包含一个函数？（P122）</li>
<li>可执行文件的装载方式（P153）</li>
</ul>
</li>
</ul>
<h3 id="2021-03-29"><a href="#2021-03-29" class="headerlink" title="2021-03-29"></a>2021-03-29</h3><ul>
<li>自修：<ul>
<li>强符号与弱符号（P92）</li>
<li>强引用与弱引用</li>
<li>静态链接的段合并策略（P99）</li>
</ul>
</li>
</ul>
<h3 id="2021-03-25"><a href="#2021-03-25" class="headerlink" title="2021-03-25"></a>2021-03-25</h3><ul>
<li>自修：<ul>
<li>初始化为 0 的静态变量/全局变量会被当成未定义变量保存在 .bss 段。</li>
</ul>
</li>
</ul>
<h3 id="2021-03-22"><a href="#2021-03-22" class="headerlink" title="2021-03-22"></a>2021-03-22</h3><ul>
<li>自我修养：<ul>
<li>编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，后端将中间代码转换成目标机器代码。</li>
<li>目标文件中数据和指令分段的好处：<ul>
<li>指令只读；数据可读写</li>
<li>指令区和数据区分离有利于提高程序的局部性，对 CPU 的缓存命中率提高有好处</li>
<li>当系统中运行着多个该程序的副本时，由于指令只读，所以可以共享</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2021-03-19"><a href="#2021-03-19" class="headerlink" title="2021-03-19"></a>2021-03-19</h3><ul>
<li>自我修养：<ul>
<li>同步与锁（P26）：<ul>
<li>二元信号量</li>
<li>多元信号量</li>
<li>互斥量</li>
<li>临界区</li>
<li>读写锁</li>
<li>条件变量</li>
</ul>
</li>
<li>CPU 的乱序执行（P29）</li>
<li>三种线程模型</li>
</ul>
</li>
</ul>
<h3 id="2021-03-18"><a href="#2021-03-18" class="headerlink" title="2021-03-18"></a>2021-03-18</h3><ul>
<li>自我修养：<ul>
<li>CPU 管理（P10）<ul>
<li>多道程序，multiprogramming</li>
<li>分时系统，time-sharing system</li>
<li>多任务系统，multi-tasking</li>
</ul>
</li>
<li>内存从分段到分页（P15）</li>
<li>线程调度（P21）<ul>
<li>优先级调度的环境下，线程的优先级改变一般有三种方式：<ul>
<li>用户指定优先级</li>
<li>根据进入等待状态的频繁程度改变优先级</li>
<li>长时间得不到执行而提升优先级</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2021-03-16"><a href="#2021-03-16" class="headerlink" title="2021-03-16"></a>2021-03-16</h3><ul>
<li>C++ Object Model:<ul>
<li>C++ 的封装性质不会带给它任何空间或者执行期的负担，但是 virtual 机制会引入布局以及存取时间上的额外负担。</li>
</ul>
</li>
</ul>
<h3 id="2021-03-15"><a href="#2021-03-15" class="headerlink" title="2021-03-15"></a>2021-03-15</h3><ul>
<li>Libtorch 用法：<code>at::Tensor torch_out = module.forward(inputs).toTensor().to(torch::kCPU);</code></li>
<li>ONNX 用法：<code>auto output_tensors = sess-&gt;Run(Ort::RunOptions(), &amp;input_name, &amp;input_tensor, 1, &amp;output_name, 1);</code></li>
</ul>
<h3 id="2021-03-14"><a href="#2021-03-14" class="headerlink" title="2021-03-14"></a>2021-03-14</h3><ul>
<li>算法：<ul>
<li>位运算：位运算可以用来判断奇偶（<code>x &amp; 1</code>）；也可以用来取代整除2（<code>x &gt;&gt;= 2</code>）</li>
<li>经常回忆一下“合法括号生成”问题（22题）。</li>
</ul>
</li>
</ul>
<h3 id="2021-03-10"><a href="#2021-03-10" class="headerlink" title="2021-03-10"></a>2021-03-10</h3><ul>
<li>Essential C++:<ul>
<li>const member function 必须同时再声明与定义中指定 const 。$P_{110}$</li>
<li>const reference class 参数不能调用 non-const 成员函数。$P_{111}$</li>
<li>基类的 constructor 中，派生类的虚函数绝对不会被调用（，以为基类的 constructor 是最先被执行的）。</li>
<li>typeid 和 dynamic_cast 都是所谓运行时类型鉴定机制（RTTI）机制的一部分。</li>
</ul>
</li>
</ul>
<h3 id="2021-03-09"><a href="#2021-03-09" class="headerlink" title="2021-03-09"></a>2021-03-09</h3><ul>
<li>Essential C++:<ul>
<li>函数默认值的解析操作由最右边开始进行</li>
<li>默认值只能够指定一次，要么在函数声明处，要么在函数定义处。通常会放在函数声明处（即头文件里）$P_{52}$</li>
<li>为什么返回类型不足以将函数重载呢？$P_{57}$</li>
<li>函数指针的形式 $P_{60}$</li>
<li>函数对象：函数对象的意义何在（，既然它能被普通独立函数取代的话）？$P_{85}$</li>
</ul>
</li>
</ul>
<h3 id="2021-03-05"><a href="#2021-03-05" class="headerlink" title="2021-03-05"></a>2021-03-05</h3><ul>
<li>Item 47: Use traits classes for information about types.<ul>
<li>5 种迭代器和其继承关系。</li>
<li>Traits class 使得 “类型相关信息”在编译期可用。它们以 templates 和 “templates 特化” 完成实现。</li>
<li>整合重载技术后，可以有效利用“在编译期可用”这一特性，从而取代运行时期的 “if…else”</li>
</ul>
</li>
<li>Item 50: Understand when it makes sense to replace new and delete.<ul>
<li>有时候我们需要自己实现一组 new 和 delete，目的可能是改善性能、对 heap 运用错误进行调试、收集 heap 使用信息。</li>
</ul>
</li>
</ul>
<h3 id="2021-03-04"><a href="#2021-03-04" class="headerlink" title="2021-03-04"></a>2021-03-04</h3><ul>
<li>区别：<code>int *a[5]</code> 和 <code>int (*a)[5]</code></li>
<li>Item 41: Understand implicit interfaces and compile-time polymorphism.<ul>
<li>Classes 和 templates 都支持接口和多态。对 classes 而言接口是显式的，以函数签名为中心，多态则是通过 virtual 函数发生在运行期；对 templates 而言接口是隐式的，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析发生于编译期。</li>
</ul>
</li>
<li>Item 42: Understand the two meaning of typename.<ul>
<li>作为 template 参数时， 关键字 class 和 typename 可以互换</li>
<li>请使用关键字 typename 来表示嵌套从属类型名，但是有两种例外情况…</li>
</ul>
</li>
<li>Item 43: Know how to access names in templatized base classes.<ul>
<li>如果继承的类是一个类模板，则子类不能调用父类的函数，因为编译认为父类可能会被特化，所以它不能确定父类到底长什么样。</li>
<li>因此解决办法就是人为承诺我要用的父类中会有这个方法，具体有3种方法可以实现(…)</li>
</ul>
</li>
</ul>
<h3 id="2021-03-03"><a href="#2021-03-03" class="headerlink" title="2021-03-03"></a>2021-03-03</h3><ul>
<li>Item 37: Never redefine a function’s inherited default parameter value.<ul>
<li>因为，virtual 函数是动态绑定的，而缺省参数值是静态绑定的。</li>
</ul>
</li>
</ul>
<h2 id="2021-02"><a href="#2021-02" class="headerlink" title="2021-02"></a>2021-02</h2><h3 id="2021-02-15"><a href="#2021-02-15" class="headerlink" title="2021-02-15"></a>2021-02-15</h3><ul>
<li>Item31: Minimize compilation dependencies between files.<ul>
<li>相依于声明式，不要相依于定义式。基于此构想的两个方法是 Handle classes 和 Interface classes。</li>
</ul>
</li>
</ul>
<h3 id="2021-02-04"><a href="#2021-02-04" class="headerlink" title="2021-02-04"></a>2021-02-04</h3><ul>
<li>vscode 修改  c_cpp_properties.json ：  <code>Control</code>+<code>Shift</code>+<code>P</code> -&gt; <code>c/c++ edit configuration</code></li>
</ul>
<h3 id="2021-02-03"><a href="#2021-02-03" class="headerlink" title="2021-02-03"></a>2021-02-03</h3><ul>
<li>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</li>
<li>c++ 正则用的 ECMAScript’s 正则语法，所以没有实现 look-behind 功能。</li>
</ul>
<h2 id="2021-01"><a href="#2021-01" class="headerlink" title="2021-01"></a>2021-01</h2><h3 id="2021-01-27"><a href="#2021-01-27" class="headerlink" title="2021-01-27"></a>2021-01-27</h3><ul>
<li>C++ 实用工具函数：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 分隔中英文字符</span></span><br><span class="line">str2vec(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; result) &#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (str[i] != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> byteCount = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (str[i] &amp; <span class="number">0x80</span> &amp;&amp; str[i] &amp; <span class="number">0x40</span> &amp;&amp; str[i] &amp; <span class="number">0x20</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (str[i] &amp; <span class="number">0x10</span>) &#123;</span><br><span class="line">              byteCount = <span class="number">4</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              byteCount = <span class="number">3</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &amp; <span class="number">0x80</span> &amp;&amp; str[i] &amp; <span class="number">0x40</span>) &#123;</span><br><span class="line">          byteCount = <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          byteCount = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result.emplace_back(str.substr(i, byteCount));</span><br><span class="line">      i += byteCount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2020-01-26"><a href="#2020-01-26" class="headerlink" title="2020-01-26"></a>2020-01-26</h3><ul>
<li>Effective C++:<ul>
<li>Item 30: Understand the ins and outs of inlining.<ul>
<li>滥用 inline 会照成程序体积太大，降低指令高速缓存装置的击中率；但是合理使用 inline 有可能使编译器优化出跟少量的机器码，提高指令高速缓存装置的击中率。</li>
<li>记住，inline 只是对编译器的一个申请，编译器在必要的时候可以拒绝编写者的这个请求。</li>
<li>思考：申请 virtual 函数为 inline 会不会成功？为什么？</li>
<li>编译器通常不对“通过函数指针而进行的调用”实施 inlineing</li>
<li>构造和析构函数一般不声明为 inline，即使他们看上去什么都没有执行。</li>
<li>修改 inline 函数要考虑程序库得升级成本，用到 inline 函数的项目需要全部重新编译。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-01-25"><a href="#2020-01-25" class="headerlink" title="2020-01-25"></a>2020-01-25</h3><ul>
<li>Effective C++:<ul>
<li>Item 29: Strive for exception-safe code.<ul>
<li>异常安全函数即使发生异常也不会泄露资源或允许任何数据结构破坏。这样的函数分为三种可能的保护级别：基本型、强烈型、不抛异常型。</li>
<li>“强烈保证”型往往能够以 copy-and-swap 实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用的各函数的 “异常安全保证” 中最弱者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-01-07"><a href="#2020-01-07" class="headerlink" title="2020-01-07"></a>2020-01-07</h3><ul>
<li>Effective C++:<ul>
<li>Item 23: Prefer non-member non-friend functions to member functions.<ul>
<li>能用 non-member 函数解决的事情（例如工具函数），最好不要写成 member 函数。</li>
<li>成员函数带来的封装性比非成员函数低（有点反直觉，但是事实就是这样）</li>
<li>非成员函数可以用 namespace 来整合，这使得非成员函数有更强的包裹弹性，而且用户可以自行扩充。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-01-04"><a href="#2020-01-04" class="headerlink" title="2020-01-04"></a>2020-01-04</h3><ul>
<li>Effective C++:<ul>
<li>Item 21: Don’t try to return a reference when you must return an object.<ul>
<li>思考 operator* 为啥不能返回一个 reference 而只能返回对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><h2 id="2020-12"><a href="#2020-12" class="headerlink" title="2020-12"></a>2020-12</h2><h3 id="2020-12-29"><a href="#2020-12-29" class="headerlink" title="2020-12-29"></a>2020-12-29</h3><ul>
<li>Effective C++:<ul>
<li>Item 13: Use objects to manage resources.<ul>
<li>为什么需要“用对象管理资源”？（大致想法是减少维护成本，不用担心资源没有被释放）<ul>
<li>许多资源被动态分配于 heap 内而后被用于单一区块或函数内。它们应该在控制流离开那个区块或函数时被释放。</li>
</ul>
</li>
<li>“用对象管理资源” 的观念就是 RAII，（Resouce Acquisition Is Initialization；资源获得时机便是初始化时机）。意思就是获得一个资源后于同一语句内以它初始化某个管理对象。</li>
<li>STL 容器要求其元素发挥“正常的”复制行为，std::auto_ptr 就不满足，shared_ptr 满足。</li>
</ul>
</li>
<li>Item 14: Think carefully about copying behaviour in resource-managing classes.<ul>
<li>在考虑如何处理 copying 操作时通常采取下面前两种策略：<ul>
<li>禁止复制</li>
<li>对底层资源祭出“引用计数”</li>
<li>复制底层资源（不常用）</li>
<li>转移底部资源的拥有权（unique_ptr）</li>
</ul>
</li>
</ul>
</li>
<li>Item 15: Provide access to raw resources in resource-managing classes.<ul>
<li>RAII class 应该提供一个 “取得原始资源” 的办法。</li>
<li>可以用现实转换（get） 或 隐式转换（operator）</li>
</ul>
</li>
<li>Item 16: Use the same form in corresponding uses of new and delete.<ul>
<li>如果在 new 表达式中使用 []（e.g. <code>... v_name = new std::string[100]</code>）, 必须在相应的 delete 表达式中也使用 [] （e.g. <code>delete [] v_name</code>）</li>
<li>担心 typedef 的使用：<code>typedef std::string AddressLines[4]</code>，这样的 typedef 很容易被误用，<code>std::string* pal = new AddressLines;</code>。delete 的时候需要用 []，但是看上去就怪怪的。</li>
</ul>
</li>
<li>Item 17: Store newed objects in smart pointers in standalone statements.<ul>
<li>推荐以独立语句将 newed 对象保存到智能指针内。如果不这样做会有问题。考虑这个例子，思考会有什么问题“processWidget(std::tr1::shared_ptr<widget>(new Widget&gt;(new Widget), priority());”</widget></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-12-22"><a href="#2020-12-22" class="headerlink" title="2020-12-22"></a>2020-12-22</h3><ul>
<li>C++ 随记：<ul>
<li>多态通过虚函数表（VMT）和虚函数指针（VPTR）来实现。VMT在编译期生成并固定不变，虚函数指针在构造对象的时候生成（期复制操作的代码由编译器自动生成，应该位于构造函数内）。</li>
</ul>
</li>
</ul>
<h3 id="2020-12-21"><a href="#2020-12-21" class="headerlink" title="2020-12-21"></a>2020-12-21</h3><ul>
<li><p>C++ 30:</p>
<ul>
<li><p><a href="https://time.geekbang.org/column/article/182902" target="_blank" rel="noopener">constexpr</a></p>
<ul>
<li>本质上 const 表示一个运行时常量，而 constexpr 表示一个编译器常量。虽然在 C++ 的演化中，const 渐渐带上了现在的 constexpr 用法，也可代表编译器常量，但有了 constexpr 之后我们应该只用 constexpr 来表示编译器常量。从编译器的角度，为了向后兼容，这俩在很多情况下还是等价的。</li>
<li><p>constexpr 变量仍是 const。意思就是下面的代码中如果不加 const 就会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span>&amp; b = a;    <span class="comment">//必须加 const</span></span><br></pre></td></tr></table></figure>
<p>为什么呢？ </p>
</li>
<li>只要能满足 constexpr 函数的条件，一个 lambda 表达式默认就是 constexpr 函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-12-15"><a href="#2020-12-15" class="headerlink" title="2020-12-15"></a>2020-12-15</h3><ul>
<li>C++ 30:<ul>
<li><a href="https://time.geekbang.org/column/article/178940" target="_blank" rel="noopener">用返回值 VS. 用输出参数</a><ul>
<li>输出参数是 C 语言的传统做法，但是这种方法的问题是不够直观，用户不看文档可能都不知道哪几个是输入参数哪几个是输出参数。</li>
<li>由于现代 C++ 有 copy 和 move 拷贝/赋值 机制，当我们 <strong>返回非引用类型的表达式</strong> 结果是一个纯右值(prvalue)，因此编译器在遇到形如 <code>auto res = ...</code> 的时候，它会认为我们实际是在构造 <code>A(...)</code>。由于 <code>...</code> 是一个纯右值，所以编译器会首先试图匹配移动函数，如果该对象不支持移动则使用拷贝函数，如果连拷贝函数也没有，就报错。</li>
<li>编译器的返回值优化是很强大的！可以自己写一个 <code>return A()</code> 的方法测试一下（当然要先写一个 class A）。</li>
</ul>
</li>
<li>模板的实例化和特例化</li>
<li><a href="https://time.geekbang.org/column/article/181608" target="_blank" rel="noopener">C++ 模板是图灵完全的</a>：即编译期可以完成所有想要的计算。</li>
</ul>
</li>
</ul>
<h3 id="2020-12-14"><a href="#2020-12-14" class="headerlink" title="2020-12-14"></a>2020-12-14</h3><ul>
<li>Effective C++<ul>
<li>Item 12: Copy all parts of an object.<ul>
<li>后期给类添加额外的变量时，别忘了同时修改 copying 函数，所有构造函数，和非标准形式的 operator=。</li>
<li>如果是派生类的话，别忘记同时复制基类的成员（通过调用合适的基类函数）。</li>
<li>不要尝试以某个 copying 函数实现另一个 copying 函数（比如 copy 构造函数调用 copy assignment 运算符，或反之，他们俩完全是不同的作用机理，不要互相调用）。如果觉得有重复代码冗余，就把共同机能放进第三个函数中，并由两个 copying 函数共同调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-12-13"><a href="#2020-12-13" class="headerlink" title="2020-12-13"></a>2020-12-13</h3><ul>
<li>Effective C++<ul>
<li>Item 08: Prevent exceptions from leaving destructors.<ul>
<li>析构函数不要抛出异常！</li>
<li>如果不得已要调用可能抛出异常的方法，也需要再单独提供一个函数，让用户有机会自己处理这个异常，而不是只能通过析构函数来处理这部分可能抛异常的流程。</li>
</ul>
</li>
<li>Item 09: Never call virtual functions during construction or destruction.<ul>
<li>不要在构造和析构函数中调用 virtual 函数！！！</li>
<li>在 base class 构造和析构期间， virtual 函数不是 virtual 函数，因为 derived class 根本不存在。</li>
<li>在 derived class 对象的 base class 构造/析构期间，对象得类型是 base class 而不是 derived class。</li>
<li>也不要在构造/析构函数中调用“调用了虚函数的函数”，以此递归。</li>
<li>如果想在构造函数中实现多态的效果（即根据 derived class 来使 base class 构造的时候采取不同的行为），解决办法是要求 derived class 构造函数传递必要的信息给 base class 的构造函数。而派生类的这个必要的信息不能用普通变量来给，要用一个静态方法来生成。记住：base class 是比 drived class 先构造的，用静态函数才能保证 base class 构造的时候能获取到这个数据。</li>
</ul>
</li>
<li>Item 10: Have assignment operators return a reference to *this.<ul>
<li>赋值操作默认采用右结合律，即 <code>x = y = z = 15</code> 相当于 <code>x = (y = (z = 15))</code>。</li>
<li>为了实现上述这种链式赋值，赋值操作符必须返回一个 reference 指向操作符的左侧实参。</li>
<li>这是一个非强制性的默认协议，该协议适用于所有赋值相关运算。</li>
</ul>
</li>
<li>Item 11: Handle assignment to self in operator=.<ul>
<li>要同时具备“自我赋值安全”和“异常安全”。</li>
<li>前者只需要做 identity test。 想达到“异常安全”需要精心设计语句顺序，这往往会自动获得“自我赋值安全”。</li>
<li>copy and swap 技术也能保证线程安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-12-11"><a href="#2020-12-11" class="headerlink" title="2020-12-11"></a>2020-12-11</h3><ul>
<li><p>Effective C++</p>
<ul>
<li>Item 05: Know what functions C++ silently writes and calls.<ul>
<li>编译器能在特定条件下自行创建默认构造函数、拷贝构造函数、拷贝赋值运算符以及析构函数。</li>
<li>只有当这些函数被调用了，编译器才会去创建。</li>
<li>以下情况会让编译器不知如何生成拷贝赋值运算，所以不会默认生成（思考为什么？）：<ul>
<li>内含 reference 成员</li>
<li>内含 const 成员</li>
<li>父类的对应方法是 private 的。</li>
</ul>
</li>
</ul>
</li>
<li>Item 06: Explicitly disallow the use of compiler-generated functions you do not want.<ul>
<li>有三种方法阻止编译器自动生成拷贝构造和拷贝赋值：<ul>
<li>= delete</li>
<li>声明为 private， 且不写定义</li>
<li>继承对应函数为 private 的基类（有很多微妙的点，比如不一定要 public 继承， 析构函数不一定要 virtual）。</li>
</ul>
</li>
</ul>
</li>
<li>Item 07: Declare destructors virtual in polymorphic base classes.<ul>
<li>如果一个基类会在多态场景中使用，即这个基类的指针或引用会用来指向派生类的对象，则该基类的析构函数必须声明为 virtual。不然 delete 的时候只会“部分释放”基类资源。可能出现 资源泄露、数据结构败坏，而且之后难以定位问题。</li>
<li>要判断一个类是否会用于多态场景中作为基类，可以通过观察该类中是不是含有 virtual 成员函数。如果不含 virtual 成员函数，则这个类大概率不会被用作基类，这时候如果还把析构函数声明成 virtual，只会徒增改对象的实际体积（会生成虚函数列表和虚函数列表指针）并降低代码的兼容性（c中没有虚函数）而不会带来任何好处。</li>
<li>尽量不要继承没有虚析构函数的类（e.g. std::string），这种情况一旦被错用到多态场景中就会有问题。</li>
<li>如果想要一个抽象 class，可以先大胆的声明一个纯虚析构函数，<code>virtual ~A() = 0</code>。</li>
<li>既然手动声明了虚析构函数，别忘了手动定义，即使函数体里什么都不用写。<h3 id="2020-12-02"><a href="#2020-12-02" class="headerlink" title="2020-12-02"></a>2020-12-02</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>C++ 易用性特性：</p>
<ul>
<li><p>自定义字面量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 米为单位的长度</span></span><br><span class="line">length <span class="keyword">operator</span><span class="string">""</span> _m(<span class="keyword">long</span> <span class="keyword">double</span> v)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> length(v, length::metre);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//厘米为单位的长度</span></span><br><span class="line">length <span class="keyword">operator</span><span class="string">""</span> _cm(<span class="keyword">long</span> <span class="keyword">double</span> v)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> length(v, length::centimetre);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 之后就可以像这样使用</span></span><br><span class="line"><span class="number">1.0</span>_m + <span class="number">10.0</span>_cm;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数字分隔符（C++14）：允许在数字型字面量中任意添加 <code>&#39;</code> 来增强数字可读性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> mask = <span class="number">0b111'000'000</span>;</span><br><span class="line"><span class="keyword">long</span> r_earth_equatorial = <span class="number">6'378'137</span>;</span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14159'26535'89793</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> magic = <span class="number">0x44'42'47'4E</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态断言：C++ 11之前只能在运行时检查 assert，但有些时候我们想在编译时就能检查一些错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>((alignment &amp; (alignment - <span class="number">1</span>)) == <span class="number">0</span>, <span class="string">"Alignment must be power of two"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>= default 和 = delete 成员函数：我们可以在编译器能默认提供特殊成员函数时将其删除，或在编译器不默认提供特殊成员函数时明确声明其需要默认提供（不过，要注意，即使用户要求默认提供，编译器也可能根据其他规则将特殊成员函数标为删除）。</p>
</li>
<li><p>override 和 final 说明符</p>
<ul>
<li>override 显式声明了成员函数是一个虚函数且覆盖了基类中的该函数。如果有 override 声明的函数不是虚函数，或基类中不存在这个虚函数，编译器会报告错误。</li>
<li>final 则声明了成员函数是一个虚函数，且该虚函数不可在派生类中被覆盖。如果有一点没有得到满足的话，编译器就会报错。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// OK</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> override final</span>; <span class="comment">// OK</span></span><br><span class="line">  <span class="comment">//void foobar() override;</span></span><br><span class="line">  <span class="comment">// 非虚函数不能 override</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">final</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// OK</span></span><br><span class="line">  <span class="comment">//void bar() override;</span></span><br><span class="line">  <span class="comment">// final 函数不可 override</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> C &#123;</span><br><span class="line">  <span class="comment">// 错误：final 类不可派生</span></span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2020-11"><a href="#2020-11" class="headerlink" title="2020-11"></a>2020-11</h2><h3 id="2020-11-26"><a href="#2020-11-26" class="headerlink" title="2020-11-26"></a>2020-11-26</h3><ul>
<li>Effective C++:<ul>
<li>Item 04: Make sure that objects are initialized before they’re used.<ul>
<li>编译器不保证会对对象进行默认初始化，所以尽量在使用对象之前先把它初始化。</li>
<li>不要混淆 赋值 和 初始化，尽量使用成员初始化列表。</li>
<li>C++ 有着十分固定的“成员初始化次序”。 base class 更早于其 derived classes 被初始化，而 class 的成员变量总是以其声明次序被初始化。成员初始化列表的排列顺序应该和他们在class 中的声明次序相同。</li>
<li>“不同编译单元内定义的 non-local static 对象”的初始化顺序是不确定的。想办法把 non-local static 对象写成 local static对象，即用函数包裹然后返回其 reference 就能保证在该 static 对象使用之前已经被初始化出来。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-11-19"><a href="#2020-11-19" class="headerlink" title="2020-11-19"></a>2020-11-19</h3><ul>
<li>Effective C++:<ul>
<li>Item 03: Use const whenever possible.<ul>
<li>当我们遇到可以用 <code>const</code> 的情况（比如有个对象“不应该被改动”），就应该用 <code>const</code> 明确地表示出来，这样能让有些意外错误在编译时期就显现出来。</li>
<li><code>const</code> 出现在 <code>*</code> 左边表示被指物是常量（可以写在类型前，也可以写在类型后，这两者是等价地）；反之出现在 <code>*</code> 右边表示指针不能指向别处；如果出现在 <code>*</code> 两侧表示被指物和指针自身都是常量。</li>
<li>对应于迭代器，被指物为常量用 <code>...::const_iterator</code> ; <code>const ...::iterator</code> 表示这个迭代器是常量。</li>
<li><code>const</code> 成员函数很重要：<ol>
<li>增强可读性。</li>
<li>使 “操作 <code>const</code> 对象” 成为可能。</li>
</ol>
</li>
<li>两个流行概念：<ul>
<li>bitwise constness</li>
<li>logical constness</li>
</ul>
</li>
<li>在 <code>const</code> 和 <code>non-const</code> 成员函数中避免重复<ul>
<li>需要理解应该是谁调用谁。 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-11-13"><a href="#2020-11-13" class="headerlink" title="2020-11-13"></a>2020-11-13</h3><ul>
<li>Effective C++:<ul>
<li>Item 01: View C++ as a federation of languages<ul>
<li>C++ 最初的名称，C with Classes</li>
<li>把 C++ 理解成四种次语言的联邦。C++ 的高效编程守则视状况而定，取决于我们使用 C++ 的哪部分：<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Templete C++</li>
<li>STL</li>
</ul>
</li>
</ul>
</li>
<li>Item 02: Prefer consts, enums, and inlines to #defines.<ul>
<li>or say “try to avoid precompilation”</li>
<li>预编译之后很多代码会被替换掉，因此编译器接触到这些被替换掉的代码，如果这部分被替换掉的代码报错了，可能会比较难定位。</li>
<li>对浮点常量而言，使用常量可能比使用 <code>#define</code> 产生较小量的代码，因为预处理器的替换可能导致目标码中出现多份同一个浮点数，而若用常量绝不会出现这种情况。</li>
<li>两种特殊情况：<ul>
<li>一是定义常量指针，有必要把指针声明成常量，以便被不同源码含入。</li>
<li>第二个值得注意的是 class 专属常量。为了确保此常量至多只有一份实体，必须让它成为一个 static 成员。</li>
</ul>
</li>
<li>尽量不要用宏函数，会有一些不可思议的问题。最好用 inline 函数替换。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-11-11"><a href="#2020-11-11" class="headerlink" title="2020-11-11"></a>2020-11-11</h3><ul>
<li>C++:<ul>
<li>运行时类型识别（run-time type identification, RTTI）使用时必须格外小心，在可能的情况下，尽量使用虚函数而不是直接接管类型管理的重任。</li>
<li>C++ 的不可移植特性：<ul>
<li>算术类型的大小在不同机器上不一样。</li>
<li>位域</li>
<li>volatile 限定符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-11-10"><a href="#2020-11-10" class="headerlink" title="2020-11-10"></a>2020-11-10</h3><ul>
<li>C++:<ul>
<li>在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以他们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身并没有捕获到该异常，则程序将被终止。</li>
<li>左值持久；右值短暂</li>
<li>处理构造函数初始值异常的唯一方法是将构造函数写成函数 try 语句块。</li>
<li>noexcept 异常说明的好处：<ul>
<li>知道函数不会抛出异常有助于简化调用该函数的代码</li>
<li>如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化，而这些优化并不适用于可能出错的代码。</li>
</ul>
</li>
<li>noexcept 需要同时出现在函数的声明和定义语句中。如果是成员函数，noexcept 说明符需要跟在 const 及引用限定符之后，而在 final、override 或虚函数的 =0 之前。</li>
</ul>
</li>
</ul>
<h3 id="2020-11-07"><a href="#2020-11-07" class="headerlink" title="2020-11-07"></a>2020-11-07</h3><ul>
<li>C++:  <ul>
<li>用花括号 <code>{}</code> 代替小括号 <code>()</code> 初始化变量被称作 “统一初始化（uniform initialization）”。使用花括号时编译器会拒绝“窄”转换，不接受以 <code>Obj{0.1}</code> 的形式调用构造函数 <code>Obj(int)</code>。这个语法主要的限制是，如果一个类既有使用初始化列表的构造函数，又有不使用初始化列表的构造函数，那编译器会千方百计地试图调用使用初始化列表的构造函数，导致各种意外。所以，如果给一个推荐的话，那就是：<ul>
<li>如果一个类没有使用初始化列表的构造函数时，初始化该类对象可全部使用统一初始化语法。</li>
<li>如果一个类有使用初始化列表的构造函数时，则只应用在初始化列表构造的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-11-02"><a href="#2020-11-02" class="headerlink" title="2020-11-02"></a>2020-11-02</h3><ul>
<li>C++:<ul>
<li>异常安全： 指当异常发生时，既不会发生资源泄露，系统也不会处于一个不一致的状态。</li>
<li>如果一个函数声明了不会抛出异常、结果却抛出了异常，C++ 运行时会调用 std::terminate 来终止应用程序。</li>
<li>exceptions pros and cons:<ul>
<li>优点：方便； 可以获得在调试和发布模式下都良好、一致的效果，而且标准库的错误处理方式就是异常。</li>
<li>缺点：编译出的二进制代码会膨胀百分之十到二十，违反了 C++ “你不用就不需要付出代价”的原则；异常比较隐蔽，不容易看出哪些地方会发生异常和发生什么异常。</li>
</ul>
</li>
<li>各种迭代器类型的关系：<img src="https://db3pap006files.storage.live.com/y4mEnAGg44uYxfHrF0R8reacZSzAh9Y7L84UMSPMfSbtpsuMwcvP3Yfch82Avu9rbFpeoSUtg9MkLvAcEq-nrBueoA-FxWb_eIaRk3SMigjZAQL7OlvKm9ZtMIqUdmVyfns-vHLUF30bCsxi4kVBCaI5y2vTCkMs4kSzQKNslljLxAN4OmT8GWnARFX8zv16Xem?width=1218&height=892&cropmode=none" width="400" height="400" title="迭代器类型的关系"></li>
<li>需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，vector 的迭代器，在很多实现里就直接是使用指针的。</li>
</ul>
</li>
</ul>
<h2 id="2020-10"><a href="#2020-10" class="headerlink" title="2020-10"></a>2020-10</h2><h3 id="2020-10-31"><a href="#2020-10-31" class="headerlink" title="2020-10-31"></a>2020-10-31</h3><ul>
<li>git:<ul>
<li><code>git cherry-pick &lt;commit id&gt;</code> : 在当前分支应用某个commit.</li>
</ul>
</li>
</ul>
<h3 id="2020-10-24"><a href="#2020-10-24" class="headerlink" title="2020-10-24"></a>2020-10-24</h3><ul>
<li><p>C++:</p>
<ul>
<li>正常情况下，向 std 名空间添加声明或定义是禁止的，属于未定义行为。 其中一个例外的情况是，我们可以对标准哈希函数做特化，</li>
<li>从实际的工程角度，无序关联容器的主要优点在于其性能。关联容器和 priority_queue 的插入和删除操作，以及关联容器的查找操作，其复杂度都是 O(log(n))，而无序关联容器的实现使用哈希表，可以达到平均 O(1)！但这取决于我们是否使用了一个好的哈希函数：在哈希函数选择不当的情况下，无序关联容器的插入、删除、查找性能可能成为最差情况的 O(n)</li>
<li>C 数组传递给一个函数后，该函数获取不到该数组的大小和结束位置，所以 C 语言中传数组的时候一般会带上数组大小，而且像这种 <code>sizeof(a) / sizeof((a)[0])</code> （假设 a 是一个 C 中传递给 A 函数的数组）做法在函数 A 中肯定能是错的。这种情况称为 <strong>数组退化成指针</strong>。</li>
<li>当我们要用到的数字小且大小固定的情况下应该用 <code>std::array</code> 来作为 C 数组， array 保留了 C 数组在栈上分配的特点，同时，提供了 begin、end、size 等通用成员函数。当然如果数组较大的话，应该考虑 vector。vector 有最大的灵活性和不错的性能。</li>
<li>为什么大部分容器都提供了 begin、end 等方法？<ul>
<li>首先是为了遍历容器方便，其次为了保证std接口的一致性</li>
</ul>
</li>
<li>为什么容器没有继承一个公用的基类？<ul>
<li>因为这儿继承真的没啥用。有了泛型，继承基本是种浪费。而且，继承用基类的指针或引用才有用，而C++里的容器类一般都是当值类型来用的。<h3 id="2020-10-14"><a href="#2020-10-14" class="headerlink" title="2020-10-14"></a>2020-10-14</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>C++:</p>
<ul>
<li>容器的 begin 和 end 是半开半闭区间：在容器非空时，begin 指向第一个元素，而 end 指向最后一个元素后面的位置；在容器为空时，begin 等于 end。在 string 的情况下，由于考虑到和 C 字符串的兼容，end 指向代表字符串结尾的 \0 字符。</li>
<li>vector 通常保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。</li>
<li>emplace_back 和 push_back(obj()) 的区别。</li>
<li>deque：<img src="https://hbz5pg.db.files.1drv.com/y4mK1Cy61ASatue4EHdhjW2-ZGTNaoEIxjwwPLAMTtzv3Ja4dzuVyp8q63v6Ex9R6zJW-wgP5giM7gkWOamL6QIUiW-t661E255VP53nQTNxMelllRY8XFJ4_N3b5lSJdhnw7DmseQ4zT6wuAVMFhUwk4oaHPdV4Al4BPbhV1QzfhwmMNDHRsluyyRLmJnnKujBm8SemtYWb5so5p0fojNWPA?width=1104&height=832&cropmode=none" width="400" height="400" title="deque 的存储结构">
<ul>
<li>如果只从头、尾两个位置对 deque 进行增删操作的话，容器里的对象永远不需要移动。</li>
<li>容器里的元素只是部分连续的（因而没法提供 data 成员函数）</li>
<li>由于元素的存储大部分仍然连续，它的遍历性能是比较高的。</li>
<li>由于每段存储大小相等，deque 支持使用下标访问容器元素，也保持高效。</li>
</ul>
</li>
<li>list:<img src="https://idghnq.db.files.1drv.com/y4mOVoNLgKDKgUpcvLDlIzqMtXRMHim2rBETwZ4yHnPtK7wp7G-s9JvUV-qmY8e3Q7oSXdJ7XKH1ZXRMV0YknNxifEGAVrF1J5Fw3UdscFvxPCHTJizqs27fu00YvRlaynYe49BlCnIvS7KGQJQJkoCHtTLoqW_xaaR701qV-LjmMb3ukNOJVEhBNVpUkk4yKdzUW1zBOrWx8jWX5inSXVlkw?width=1388&height=788&cropmode=none" width="400" height="400" title="list 存储结构">
<ul>
<li>list 在 C++ 中代表双向链表。</li>
<li>因为某些标准算法在 list 上会导致问题，list 提供了成员函数作为替代，包括下面几个：<ul>
<li>merge</li>
<li>remove</li>
<li>remove_if</li>
<li>reverse</li>
<li>sort</li>
<li>unique</li>
</ul>
</li>
<li>容器适配器：queue 和 stack，缺省都是用 deque 来实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-10-13"><a href="#2020-10-13" class="headerlink" title="2020-10-13"></a>2020-10-13</h3><ul>
<li><p>程序的局部性原理：当一个程序运行时，在某个时间段内，它只是频繁地用到了一小部分数据。</p>
</li>
<li><p>Memory Management Unit： 控制页映射地部件，CPU 发出地指令都是用 Virtual Address。</p>
</li>
<li><p>C++：</p>
<ul>
<li><a href="https://time.geekbang.org/column/article/169268" target="_blank" rel="noopener">右值和移动解决了什么问题</a>：<ul>
<li>“value category” 和 “value type” 是两个不相干的术语： 前者值类别指的是“这个值是左值还是右值”， 后者“值类型”是跟“引用类型”相对得一个概念。 C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（&amp;）和指针（*）才是引用类型。在 Java 里，数字等原生类型是值类型，类则属于引用类型。在 Python 里，一切类型都是引用类型。</li>
<li>不要返回本地变量的引用</li>
<li>返回值优化：把对象直接构造到调用者的栈上。</li>
<li>引用折叠和转发</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-10-03"><a href="#2020-10-03" class="headerlink" title="2020-10-03"></a>2020-10-03</h3><ul>
<li>C++：<ul>
<li>new 和 delete 操作的区域是 free store；malloc 和 free 操作的区域是 heap。但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。</li>
<li>在 C++ 里，所有的变量缺省都是值语义——如果不使用 * 和 &amp; 的话，变量不会像 Java 或 Python 一样引用一个堆上的对象。</li>
</ul>
</li>
</ul>
<h2 id="2020-09"><a href="#2020-09" class="headerlink" title="2020-09"></a>2020-09</h2><h3 id="2020-09-29"><a href="#2020-09-29" class="headerlink" title="2020-09-29"></a>2020-09-29</h3><ul>
<li>自我修养：  <ul>
<li>计算机得核心：<ul>
<li>CPU</li>
<li>内存</li>
<li>I/O 控制芯片</li>
</ul>
</li>
<li>计算机（层级）软件体系结构，P9.</li>
<li>操作系统职能:<ul>
<li>提供编程接口</li>
<li>管理硬件资源，挖掘 CPU、存储器和 I/O 设备得潜力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-09-16"><a href="#2020-09-16" class="headerlink" title="2020-09-16"></a>2020-09-16</h3><ul>
<li><p>Linux 命令：</p>
<ul>
<li>ldd  libvad.so: 查看该动态库的依赖。</li>
<li><p>nm libvad.so: 查看动态和静态库中的符号。</p>
<ul>
<li><p>有用的options:</p>
<ul>
<li>-A 在每个符号信息的前面打印所在对象文件名称；</li>
<li>-C 输出demangle过了的符号名称；</li>
<li>-D 打印动态符号；</li>
<li>-l 使用对象文件中的调试信息打印出所在源文件及行号；</li>
<li>-n 按照地址/符号值来排序；</li>
<li>-u 打印出那些未定义的符号；</li>
<li><p>常见的符号类型:</p>
</li>
<li><p>A 该符号的值在今后的链接中将不再改变；</p>
</li>
<li>B 该符号放在BSS段中，通常是那些未初始化的全局变量；</li>
<li>D 该符号放在普通的数据段中，通常是那些已经初始化的全局变量；</li>
<li>T 该符号放在代码段中，通常是那些全局非静态函数；</li>
<li>U 该符号未定义过，需要自其他对象文件中链接进来；</li>
<li>W 未明确指定的弱链接符号；同链接的其他对象文件中有它的定义就用上，否则就用一个系统特别指定的默认值。</li>
</ul>
</li>
</ul>
</li>
<li>awk: 一种处理文本文件的语言</li>
</ul>
</li>
</ul>
<h3 id="2020-09-10"><a href="#2020-09-10" class="headerlink" title="2020-09-10"></a>2020-09-10</h3><ul>
<li>C++:<ul>
<li>默认参数不能在声明和定义中同时出现。</li>
</ul>
</li>
</ul>
<h3 id="2020-09-08"><a href="#2020-09-08" class="headerlink" title="2020-09-08"></a>2020-09-08</h3><ul>
<li>C++（函数匹配）：<ul>
<li>编译器进行函数匹配时，将实参到形参的类型转化划分了几个等级，从上到下优先级由高到低（P219）：<ol>
<li>精准匹配，包括以下情况：<ul>
<li>实参类型和形参类型完全一致。</li>
<li>实参从数组类型或者函数类型转换成对应的指针类型。</li>
<li>向实参添加顶层 const 或 从实参中删除顶层 const。 </li>
</ul>
</li>
<li>通过 const 转换实现的匹配。</li>
<li>通过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配</li>
<li>通过类类型转换实现的匹配。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2020-09-07"><a href="#2020-09-07" class="headerlink" title="2020-09-07"></a>2020-09-07</h3><ul>
<li><p>C++（模板与泛型编程）：</p>
<ul>
<li><p>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const 转换及数组或函数到指针的转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span> <span class="params">(T, T)</span></span>; <span class="comment">// 实参被拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span> <span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;  <span class="comment">// 引用</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"another value"</span>)</span></span>;</span><br><span class="line">fobj (s1, s2);         <span class="comment">// 调用 fobj(string, string); 顶层 const 被忽略</span></span><br><span class="line">fref (s1, s2);         <span class="comment">// 调用 fref(const string&amp;, const string&amp;)；将 s1 转化成 const 是允许的</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], b[<span class="number">20</span>];</span><br><span class="line">fobj (a, b);           <span class="comment">// 调用 fobj(int*, int*)</span></span><br><span class="line">fref (a, b);           <span class="comment">// 错误：数组类型不匹配，如果形参是个引用，则数组不会转换为指针。</span></span><br><span class="line">                       <span class="comment">// 数组长度不同，因此是不同类型。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尾置返回类型在函数模板中的妙用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt;decltype(*beg)&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 思考为何这里要（只能）用尾置返回类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，decltype 方法返回的是 beg 解引用后的类型的引用，但如果我们不想要让函数返回引用，而是返回元素值得一个拷贝，还需要用 remove_reference 脱去引用。则上面得 <code>decltype(*beg)</code> 需要改成 <code>typename remove_reference&lt;decltype(*beg)&gt;::type</code></p>
</li>
<li>引用折叠只能应用于间接创建的引用的引用，如类型别名和模板参数。（暂时理解不了，先记住有这个东西吧。）这导致：如果一个函数参数是指向模板参数类型得右值引用，则可以传递给它任意类型得实参。如果将一个左值传递给这样得参数，则函数参数被实例化为一个普通得左值引用（发生了引用折叠）。</li>
<li>正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限的实参类型转换有深刻的理解。（我目前的理解就不够深刻，写这类重载前需要考虑清楚。）</li>
</ul>
</li>
</ul>
<h3 id="2020-09-04"><a href="#2020-09-04" class="headerlink" title="2020-09-04"></a>2020-09-04</h3><ul>
<li>C++ 检查类型是否为整型或者是否为浮点型，用这种方法在编译时就会报错（如果类型不匹配的话）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdecCompileTimeAssert</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdecCompileTimeAssert</span>&lt;true&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Check</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEC_COMPILE_TIME_ASSERT(b) IdecCompileTimeAssert<span class="meta-string">&lt;(b)&gt;::Check()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEC_ASSERT_IS_INTEGER_TYPE(I) \</span></span><br><span class="line">  IdecCompileTimeAssert&lt;<span class="built_in">std</span>::numeric_limits&lt;I&gt;::is_specialized \</span><br><span class="line">                &amp;&amp; <span class="built_in">std</span>::numeric_limits&lt;I&gt;::is_integer&gt;::Check()</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEC_ASSERT_IS_FLOATING_TYPE(F) \</span></span><br><span class="line">  IdecCompileTimeAssert&lt;<span class="built_in">std</span>::numeric_limits&lt;F&gt;::is_specialized \</span><br><span class="line">                &amp;&amp; !<span class="built_in">std</span>::numeric_limits&lt;F&gt;::is_integer&gt;::Check()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2020-09-01"><a href="#2020-09-01" class="headerlink" title="2020-09-01"></a>2020-09-01</h3><ul>
<li>C++（异常处理）：<ul>
<li>在栈展开的过程中，会运行局部对象的析构函数。因为这些析构函数是自动执行的，所以他们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数本身没有捕获到该异常，则程序将被终止。</li>
<li>当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。</li>
</ul>
</li>
</ul>
<h2 id="2020-08"><a href="#2020-08" class="headerlink" title="2020-08"></a>2020-08</h2><h3 id="2020-08-19"><a href="#2020-08-19" class="headerlink" title="2020-08-19"></a>2020-08-19</h3><ul>
<li>C++（模板与泛型编程）：<ul>
<li>模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，必须是可见的。</li>
<li>大多数编译错误在实例化期间报告</li>
<li>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</li>
<li>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。（P.588）</li>
<li>当我们希望通知编译器一个名字表示类型时，必须使用关键字 typename，而不能使用 class。</li>
<li>显式实例化可以避免在不同文件中实例化一样的实例造成的开销，但是类模板显式实例化的时候要注意，它会实例化该模板的所有成员（普通的模板类实例化是用到啥才实例化啥）</li>
</ul>
</li>
</ul>
<h3 id="2020-08-18"><a href="#2020-08-18" class="headerlink" title="2020-08-18"></a>2020-08-18</h3><ul>
<li><p>C++ （面向对象程序设计）：</p>
<ul>
<li>如果虚函数使用了默认实参，则基类和派生类中定义的默认实参最好一致。（原因见 P.539）</li>
<li>派生访问说明符（<code>class Pub_Derv : public Base {}</code>）是用来控制派生类用户对于基类成员的访问权限。</li>
<li>派生类向基类转换的可访问性（见P.544）：对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</li>
<li>不能继承友元关系；每个类负责控制各自成员的访问权限。(P.545)</li>
<li><p>改变个别成员的可访问性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使 Derived 类的用户也可访问 Base::size</span></span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//使 Derived 类的成员、友元和派生类可访问 Base::n</span></span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 struct 和 class 关键字定义的类之间的唯一差别就是默认成员访问说明符及默认派生访问说明符。</p>
</li>
<li>派生类的作用域位于基类作用域之内。</li>
<li>在编译时进行名字查找，所以我们能使用哪些成员仍然是有由静态类型决定的。</li>
<li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其它定义在基类中的名字，基类中的名字会被覆盖，管理起来比较繁琐。</li>
<li>名字查找先于类型检查：声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此派生类中的函数也不会重载其基类中的成员，即使派生类成员和基类成员的形参列表不一致，基类成员也仍然回被隐藏掉（不过可以用作用域运算符显示调用基类的成员）。</li>
<li>为什么要把基类的析构函数定义成虚函数（见P.552）</li>
<li>容器和存在继承关系的类型无法兼容，因为当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”。解决办法是存放基类的指针（更好的选择是智能指针）。</li>
</ul>
</li>
</ul>
<h3 id="2020-08-17"><a href="#2020-08-17" class="headerlink" title="2020-08-17"></a>2020-08-17</h3><ul>
<li>C++ （面向对象程序设计）：<ul>
<li>oop 的核心思想是数据抽象、继承和动态绑定（也叫运行时绑定）</li>
<li>成员函数如果没有声明为虚函数，则其解析过程发生在编译时而非运行时。</li>
<li>在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。P.530</li>
<li>每个类控制它自己的成员初始化过程。P.531</li>
<li>基类的指针或引用的静态类型可能与动态类型不一致。</li>
</ul>
</li>
</ul>
<h3 id="2020-08-14"><a href="#2020-08-14" class="headerlink" title="2020-08-14"></a>2020-08-14</h3><ul>
<li>C++ （重载运算与类型转换）：<ul>
<li>lambda 表达式是一种简便的未命名函数对象类。</li>
<li>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</li>
<li>如果表达式被用作条件，则显式的（explicit）类型转换将被隐式地执行：<ul>
<li>if、while 及 do 语句地条件部分</li>
<li>for 语句头地条件表达式</li>
<li>逻辑于/或/非运算符地运算对象（！、||、&amp;&amp;）</li>
<li>条件运算符（？：）的条件表达式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-08-13"><a href="#2020-08-13" class="headerlink" title="2020-08-13"></a>2020-08-13</h3><ul>
<li><p>C++ （重载运算与类型转换）：</p>
<ul>
<li>对于要给运算符函数来说，它要么是类的成员函数，要么至少含有一个类类型的参数。</li>
</ul>
</li>
<li><p>修改 nginx 文件列表中的文件名显示长度，要修改 src/http/modules/ngx_http_autoindex_module.c 中的 <code>#define NGX_HTTP_AUTOINDEX_PREALLOCATE 50</code> 和 <code>#define NGX_HTTP_AUTOINDEX_NAME_LEN 50</code>。</p>
</li>
</ul>
<h3 id="2020-08-11"><a href="#2020-08-11" class="headerlink" title="2020-08-11"></a>2020-08-11</h3><ul>
<li><p>C++ （拷贝控制）：</p>
<ul>
<li><p>使用拷贝和交换（copy and swap）的赋值运算自动就是异常安全的，且能正确处理自赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意 rhs 是按值传递的，意味着 HasPtr 的拷贝构造函数</span></span><br><span class="line"><span class="comment">// 将右侧运算对象中的 string 拷贝到 rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 交换左侧运算对象和局部变量 rhs 的内容</span></span><br><span class="line">    swap(*<span class="keyword">this</span>, rhs);     <span class="comment">// rhs 现在指向本对象曾经使用的内存</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;         <span class="comment">// rhs 被销毁，从而 delete 了 rhs 中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是左值引用类型也不行。</p>
</li>
<li>显示的告诉标准库我们的移动构造函数一定安全使用 <code>noexcept</code></li>
<li>编译器自动生成合成移动构造函数或移动赋值运算符的条件：<ul>
<li>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时。</li>
</ul>
</li>
<li>限定 运算符（e.g. <code>=</code>）左侧 运算对象是一个左值/右值：<ul>
<li>类似定义 const 成员函数，在参数列表后放置一个引用限定符 <code>&amp;</code>（左值） 或者 <code>&amp;&amp;</code>（右值）</li>
<li>必须同时出现在函数的声明和定义中</li>
<li>如果要同时用 const 和 引用限定的话，引用限定符必须跟随在 const 限定符之后： <code>Int funcName() const &amp;;</code></li>
</ul>
</li>
<li>应用限定符也可以区分重载版本，而且可以综合引用限定符和 const 限定符来区分一个成员函数的重载版本。但是如果要用到引用限定符来重载，对于所有能构成重载的函数，要么都用限定符，要么都不用限定符。</li>
</ul>
</li>
</ul>
<h3 id="2020-08-06"><a href="#2020-08-06" class="headerlink" title="2020-08-06"></a>2020-08-06</h3><ul>
<li><p>C 编译器的字节对齐（向4的整数对齐）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span> <span class="keyword">int</span> a; <span class="keyword">char</span> b; <span class="keyword">int</span> c; &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,"</span>, <span class="keyword">sizeof</span>(struct X)); <span class="comment">// 输出 12</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span> <span class="keyword">int</span> a; <span class="keyword">char</span> b; <span class="keyword">int</span> c; <span class="keyword">char</span> d&#125;;</span><br><span class="line">print(<span class="string">"%d,"</span>, <span class="keyword">sizeof</span>(struct Y)); <span class="comment">// 输出 16</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针和数组体现在汇编代码中的差别：</p>
<ul>
<li>char s[0] —— 汇编代码：lea 0x04(%rax), %rdx —— 把地址放进去</li>
<li>char *s —— 汇编代码：mov 0x04(%rax), %rdx —— 把地址里的内容放进去</li>
</ul>
</li>
</ul>
<h3 id="2020-08-05"><a href="#2020-08-05" class="headerlink" title="2020-08-05"></a>2020-08-05</h3><ul>
<li><p>C++：</p>
<ul>
<li>需要析构函数的类也需要拷贝和赋值操作</li>
<li>需要拷贝操作的类也需要赋值操作。</li>
<li><p>可以用 <code>=default</code> 来显式地要求编译器生成合成版本地函数：</p>
<ul>
<li>当我们在类内用 =default 修饰成员地声明时，合成地函数将隐式地声明为内联地（就像其他类内声明地成员函数一样）</li>
<li>如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用 <code>=default</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝控制成员</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;);</span><br><span class="line">    ~Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>阻止拷贝：</p>
<ul>
<li>用 <code>=delete</code>（推荐方法）</li>
<li>private 控制拷贝 （传统方法，不推荐）</li>
</ul>
</li>
<li>试图访问一个未定义的成员将导致链接时错误。</li>
<li>拷贝控制和资源管理：<ul>
<li>行为像值得类：要注意底层值得拷贝</li>
<li>行为像指针得类：引用要计数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-08-04"><a href="#2020-08-04" class="headerlink" title="2020-08-04"></a>2020-08-04</h3><ul>
<li>C/C++:<ul>
<li>数组本质上仍然是指针，是一个存放地址等于自身地址的顶层 const 指针，即对于数组名 a，a = &amp;a。可以用代码验证。</li>
</ul>
</li>
<li>C++：<ul>
<li>拷贝控制操作：<ul>
<li>拷贝构造函数： 第一个参数必须是自身类类型的引用（思考为何？），且任何额外的参数都有默认值。</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数（新标准引入）</li>
<li>移动赋值运算符（新标准引入）</li>
<li>析构函数</li>
</ul>
</li>
<li>数组不能直接拷贝和赋值</li>
</ul>
</li>
<li>何时触发拷贝初始化<ul>
<li>用 = 定义变量时</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类的成员</li>
</ul>
</li>
</ul>
<h3 id="2020-08-03"><a href="#2020-08-03" class="headerlink" title="2020-08-03"></a>2020-08-03</h3><ul>
<li>Mathematics for Machine Learnning:<ul>
<li>linear algebra is the study of vector and certain rules to manipulate vectors.</li>
</ul>
</li>
</ul>
<h2 id="2020-07"><a href="#2020-07" class="headerlink" title="2020-07"></a>2020-07</h2><h3 id="2020-07-24："><a href="#2020-07-24：" class="headerlink" title="2020-07-24："></a>2020-07-24：</h3><ul>
<li>C++，动态内存：<ul>
<li>静态内存用来保存局部 static 对象、类 static 数据成员以及定义在任何函数之外的变量；栈内存用来保存定义在函数内的非 static 对象。</li>
<li>程序使用动态内存的三种原因：<ul>
<li>程序不知道自己需要使用使用多少对象</li>
<li>程序不知道所需对象的具体类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-07-22"><a href="#2020-07-22" class="headerlink" title="2020-07-22:"></a>2020-07-22:</h3><ul>
<li>C++， 泛型算法：<ul>
<li>那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</li>
<li>谓词（predicate），一元谓词，二元谓词；lambda 表达式</li>
</ul>
</li>
</ul>
<h3 id="2020-07-21"><a href="#2020-07-21" class="headerlink" title="2020-07-21:"></a>2020-07-21:</h3><ul>
<li>C++，顺序容器:<ul>
<li>当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了，连容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。</li>
<li>与其他容器不同，对一个 string 调用 swap 会导致迭代器、引用和指针失效。</li>
<li>与其他容器不同，对一个 array 调用 swap 会真正交换他们的元素。</li>
<li>新标准库中，swap 有成员版和非成员版，统一使用非成员版本的 swap 是一个好习惯。</li>
<li>向一个 vector、string、deque 中插入元素会使所有指向容器的迭代器、引用和指针失效。</li>
<li>容器中访问元素的函数返回的都是引用，如果容器是一个 const 对象，则返回的是 const 引用。</li>
<li>Vector 扩容策略：当不得不获取新的内存空间时，vector 和 string 的实现通常会分配比新的空间需求更大的内存空间，作为备用。</li>
<li>capacity 和 size: size 是指它已经保存的元素数量；而 capacity 则是指在不分配新的内存空间的前提下它最多可以保存多少元素。</li>
</ul>
</li>
</ul>
<h2 id="2020-06"><a href="#2020-06" class="headerlink" title="2020-06"></a>2020-06</h2><h3 id="2020-06-30"><a href="#2020-06-30" class="headerlink" title="2020-06-30"></a>2020-06-30</h3><ul>
<li>C++：<ul>
<li>当一个输入流被关联到一个输出流时（比如 cout 和 cin），任何试图从输入流读取数据的操作都会先刷新关联的输出流。所以在使用 cin 之前，cout 的缓冲区会被刷新。在交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。</li>
<li>IO 流的状态：<code>strm::badbit</code>  <code>strm::failbit</code> <code>strm::eofbit</code> <code>strm::goodbit</code></li>
</ul>
</li>
</ul>
<h3 id="2020-06-29"><a href="#2020-06-29" class="headerlink" title="2020-06-29"></a>2020-06-29</h3><ul>
<li>C++:<ul>
<li>类外定义的函数，因为返回值在类名之前，所以返回值的类型名是位于该类的作用域之外的，使用的时候要注意。</li>
<li>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。但是在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;       <span class="comment">// 使用外层作用域的 Money</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money;                 <span class="comment">// 错误：不能重新定义 Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>委托构造函数</li>
<li>关键字：explicit：抑制构造函数定义的隐式转换。<ul>
<li>只对一个实参的构造函数有效。因为需要多个实参的构造函数不能用于执行隐式转换，所以也无需用到 explicit</li>
<li>只能在类内声明构造函数时使用 explicit 关键字，在类外实现部分不应重复。</li>
<li>static_cast 可以使用 explicit 修饰过的构造函数</li>
</ul>
</li>
</ul>
<h3 id="2020-06-28"><a href="#2020-06-28" class="headerlink" title="2020-06-28"></a>2020-06-28</h3><ul>
<li>C++:<ul>
<li>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</li>
<li>IO 类型不能被拷贝，传参只能用引用的方式。</li>
<li>mutable 声明的成员变量，即使是在 const 成员函数中也能被修改</li>
<li>当我们提供一个类内初始值时，必须以符号 = 或者花括号 {} 表示</li>
</ul>
</li>
</ul>
<h3 id="2020-06-23"><a href="#2020-06-23" class="headerlink" title="2020-06-23"></a>2020-06-23</h3><ul>
<li>C 和 C++ 中的结构体区别<ul>
<li>C 语言中的结构体不能为空，否则报错</li>
<li>C 语言中的结构体不能定义成员函数（只能定义函数指针），C++ 中的结构体可以定义成员函数。</li>
<li>C 语言定义结构体变量的时候，结构体名前的 “struct” 不能省略，但在 C++ 中可以省略。</li>
</ul>
</li>
<li>C++ 中 struct 和 class 的区别：<ul>
<li>概念： class 和 struct的语法基本相同，从声明到使用，都很相似，但是struct的约束要比class多，理论上，struct能做到的class都能做到，但class能做到的stuct却不一定做的到。</li>
<li>类型：struct是值类型，class是引用类型，因此它们具有所有值类型和引用类型之间的差异。</li>
<li>效率：由于堆栈的执行效率要比堆的执行效率高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，而class来处理某个商业逻辑。</li>
<li>关系：struct不仅能继承也能被继承 ，而且可以实现接口，不过Class可以完全扩展。内部结构有区别，struct只能添加带参的构造函数，不能使用abstract和protected等修饰符，不能初始化实例字段。</li>
<li>如何选择：<ul>
<li>在表示诸如点、矩形等主要用来存储数据的轻量级对象时，首选struct。</li>
<li>在表示数据量大、逻辑复杂的大对象时，首选class。</li>
<li>在表现抽象和多级别的对象层次时，class是最佳选择 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-06-22"><a href="#2020-06-22" class="headerlink" title="2020-06-22"></a>2020-06-22</h3><blockquote>
<div title="皱眉"> in this day and age </div>
<div title="转向灯"> blinker </div>


</blockquote>
<ul>
<li><p>Einstein：</p>
<ul>
<li>“The definition of genius is taking the complex and making it simple.”</li>
</ul>
</li>
<li><p>linux:</p>
<ul>
<li>过滤错误管道输出：2&gt;&amp;- 或者 2&gt;/dev/null</li>
</ul>
</li>
</ul>
<h3 id="2020-06-16"><a href="#2020-06-16" class="headerlink" title="2020-06-16"></a>2020-06-16</h3><ul>
<li><p>C++：</p>
<ul>
<li>形参初始化的机理与变量初始化一致</li>
<li>形参会忽略顶层 const，所以 <code>void fcn(const int i)</code> 和 <code>void fcn(int i)</code> 一起用的话算重复定义。但是底层 const 可以实现函数重载，比如 <code>void fcn(int &amp;i)</code> 和 <code>void fcn(const int &amp;i)</code>，把引用换成指针也可以。</li>
<li><p>形参的初始化和变量的初始化方式是一样的，所以先看如下的初始化过程，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;i;  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;    <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span> *p = cp;         <span class="comment">// 错误：p 和 cp 的类型不匹配</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = r;         <span class="comment">// 错误：r3 和 r 的类型不匹配</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = <span class="number">42</span>         <span class="comment">// 错误：不能用字面值初始化一个非常量引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再思考下面的这些形参调用是否正确，其中 reset 函数的声明是 <code>void reset(int &amp;i)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="built_in">string</span>::size_type ctr = <span class="number">0</span>;</span><br><span class="line">reset(&amp;i);     <span class="comment">// ...</span></span><br><span class="line">reset(&amp;ci);    <span class="comment">// ...</span></span><br><span class="line">reset(i);      <span class="comment">// ...</span></span><br><span class="line">reset(ci);     <span class="comment">// ...</span></span><br><span class="line">reset(<span class="number">42</span>);     <span class="comment">// ...</span></span><br><span class="line">reset(ctr);    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int &amp;arr[10]</code> 引用的数组；<code>int (&amp;arr)[10]</code> 具有10个整数的数组的引用。其中的引用符号改成指针符号也是同理。</p>
</li>
<li>函数不要返回局部对象的引用或者指针，因为在函数完成后，它所占用的存储空间就被释放掉了。</li>
<li>返回引用的函数得到左值，其他返回类型得到右值。所以可以像使用其他左值那样来使用返回引用的函数。 </li>
<li><code>typedef int arrT[10]</code> 等价于 <code>using arrT = int[10]</code></li>
<li>函数重载不允许只有返回类型不同。</li>
<li>在不同的作用域中无法重载函数名</li>
<li>函数匹配，3步。从 <strong>候选函数</strong>（根据函数名和作用域） → <strong>可行函数</strong> → <strong>最佳匹配</strong></li>
</ul>
</li>
</ul>
<h3 id="2020-06-15"><a href="#2020-06-15" class="headerlink" title="2020-06-15"></a>2020-06-15</h3><ul>
<li>Python:<ul>
<li>subprocess.run 和 subprocess.Popen 的区别：前者等执行完了返回结果，后者需要自己调用方法拿结果。</li>
<li><code>if __name__ == &quot;__main__&quot;</code> 的作用</li>
</ul>
</li>
</ul>
<h3 id="2020-06-11"><a href="#2020-06-11" class="headerlink" title="2020-06-11"></a>2020-06-11</h3><ul>
<li>C++<ul>
<li>delete — new ; malloc — free</li>
<li>后面带 const 的函数：<ul>
<li>不能修改成员变量</li>
<li>const关键字是该函数签名的一部分，因此同一个类里可以有同名的非 const 方法。</li>
</ul>
</li>
<li>关于类型转换和各种 *_cast:<ul>
<li>隐式转换（implicit conversion）:<ul>
<li>有些情况会有精度损失而且编译器会报 warning</li>
<li>如果类 B 有构造函数是以类 A 为参数的话，由于存在隐式转换，可以把 A 的实例赋值给以 B 为类型的变量。</li>
</ul>
</li>
<li>显示转换（explicit conversion）：<ul>
<li>最常用的基础数据类型之间的类型转换有两种写法：<code>b = (int)a // c-like cast notation</code> or <code>b = int(a) // functional notation</code></li>
<li>上述方法可以应付大多数情况，但是如果用这种方法强行转换复杂类型（比如自定义类和指向类的指针）的话会出现一些不可预知的运行时错误（这样做一般能通过编译，因为编译器不会去确认能不能强转）。因此，C++ 提供了如下几个显示强转的方法：<ul>
<li>dynamic_cast:<ul>
<li>只能作用于指针或者引用，只能从派生类转到基类，目的是确保类型转化的结果是合法的。runtime 阶段检查合法性，对于不合法的类型转换，指针会返回 Null pointer，引用会抛出异常。</li>
</ul>
</li>
<li>static_cast:<ul>
<li>不仅可以从派生类到基类也可以从基类到派生类，也就是说 runtime 阶段没有了安全性检测，这部分工作要有程序员自己确认。</li>
<li>可以用于别的、非指针类型的对象</li>
</ul>
</li>
<li>reinterpret_cast:<ul>
<li>可以在任意类的指针之间转换，这个操作就是简单地拷贝一个指针对象中的二进制值给另一个指针变量。</li>
<li>甚至可以指针和整数之间相互转化，指针和整数之间的对应关系因系统而异，但是可以确定的是，在同一个系统中这个过程是可逆的，即由指针转换过来的整数一样可以转回原来的指针。</li>
</ul>
</li>
<li>const_cast:<ul>
<li>这个用来修改对象的 constness。</li>
<li>当一个函数要求的不是 const 型的参数，但是我们又想传入的参数是 const 型的话，可以在调用函数的时候用这个转换一下。</li>
</ul>
</li>
</ul>
</li>
<li>查看表达式的类型：typeid(expression)<ul>
<li>包含在头文件 <typeinfo> 中。</typeinfo></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-06-10"><a href="#2020-06-10" class="headerlink" title="2020-06-10"></a>2020-06-10</h3><ul>
<li><p>C++</p>
<ul>
<li>默认情况下，const 对象仅在文件内有效。<ul>
<li>因为 const 对象必须在声明时初始化，但是又要避免多个文件对同一个变量的重复定义。</li>
<li>解决的办法是，对于 const 对象不管是声明还是定义都添加 exern 关键字，这样只需在一个文件中定义一次就可以了。</li>
</ul>
</li>
<li>指向常量的指针或引用，只是它们自己觉得他们指向了常量，所以自觉地不去改变所指向的对象的值</li>
<li>指针是一个常量（<code>int *const name</code>） vs. 指向常量的指针（<code>const int *name</code>）</li>
<li>求值顺序：<code>a = f(x) * g(x) + h(x)</code>，f、g、h、三个函数不确定哪个先运行。</li>
</ul>
</li>
<li><p>单词常见前缀、词根、后缀</p>
<ul>
<li>fort - strong - effor，fortress</li>
<li>al - relating to - historical, rehearsal</li>
</ul>
</li>
</ul>
<h3 id="2020-06-09"><a href="#2020-06-09" class="headerlink" title="2020-06-09"></a>2020-06-09</h3><ul>
<li>ssh “Permission denied” 可能的原因：<ul>
<li>密钥没有 add ，<code>ssh-add</code></li>
<li>权限不对， 私钥要用 <code>chmod 600</code></li>
<li>gnome-keyring 的问题<ul>
<li>确诊： ssh 命令前加 <code>SSH_AUTH_SOCK=0</code> 后症状消失</li>
<li>解决： 1. 开机启动吧 “SSH Key Agent” 关了，之后重启；2. <code>killall gnome-keyring-daemon</code>, 关了应该就能用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-06-03"><a href="#2020-06-03" class="headerlink" title="2020-06-03"></a>2020-06-03</h3><ul>
<li>Peter Frankopan (牛津大学国际历史学教授): 如果我们不关注历史（包括东西方历史），我们就失去了看向正确方向的能力。人们喜欢改变、革命、改革、战争，往往低估了和平（或者平和）的重要性。</li>
</ul>
<h3 id="2020-06-02"><a href="#2020-06-02" class="headerlink" title="2020-06-02"></a>2020-06-02</h3><ul>
<li>感知机 ($f(x)=\textbf{w}^T\textbf{x}-t$) 更新参数<ul>
<li>$w_j=w_j-\alpha\times(\hat{y}-y)\times x_j$</li>
<li>$t=t+\alpha \times(\hat{y}-y)$</li>
</ul>
</li>
<li>模型容量</li>
<li>没有免费午餐定理</li>
<li>奥卡姆剃刀：选用 “最简单” 假设</li>
<li>平衡偏差和方差以最小化均方误差<ul>
<li>偏差和方差度量着估计量的两个不同误差来源，<ul>
<li>偏差度量着偏离真实函数或参数的误差期望</li>
<li>方差度量着数据上任意特定采样可能导致的估计期望的偏差</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-06-01"><a href="#2020-06-01" class="headerlink" title="2020-06-01"></a>2020-06-01</h3><ul>
<li>数值计算<ul>
<li>上溢和下溢</li>
</ul>
</li>
</ul>
<h2 id="2020-05"><a href="#2020-05" class="headerlink" title="2020-05"></a>2020-05</h2><h3 id="2020-05-29"><a href="#2020-05-29" class="headerlink" title="2020-05-29"></a>2020-05-29</h3><blockquote>
<div title="缰绳，驾驭；勒住（马）"> rein </div>
<div title="皱眉"> furrow brows </div>



</blockquote>
<h3 id="2020-05-28"><a href="#2020-05-28" class="headerlink" title="2020-05-28"></a>2020-05-28</h3><ul>
<li><p>协方差</p>
</li>
<li><p>sigmoid 函数 $\sigma(x)=\frac{1}{1+e^{-x}}=\frac{e^x}{e^x+1}$; softplus 函数 $\zeta(x)=\log(1+e^x)$</p>
<ul>
<li>$\frac{d}{dx}\sigma(x)=\sigma(x)(1-\sigma(x))$</li>
<li>$1-\sigma(x)=\sigma(-x)$</li>
<li>$\log\sigma(x)=-\zeta(-x)$</li>
<li>$\frac{d}{dx}\zeta(x)=\sigma(x)$</li>
<li>$\zeta(x)-\zeta(-x)=x$</li>
</ul>
</li>
</ul>
<h3 id="2020-05-27"><a href="#2020-05-27" class="headerlink" title="2020-05-27"></a>2020-05-27</h3><ul>
<li><p>C:</p>
<ul>
<li>char* 转int 用 atoi() ；反过来用 sprintf()</li>
<li>线程有自己的 stack，但是没有单独的 heap，也没有单独的 address space。只有进程有自己的 address space，而这个 space 中经过合法申请的部分叫做 process space。Process space 之外的地址都是非法地址。当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。   </li>
</ul>
</li>
<li><p>概率密度函数（PDF）和概率质量函数（PMF）</p>
</li>
</ul>
<h3 id="2020-05-25"><a href="#2020-05-25" class="headerlink" title="2020-05-25"></a>2020-05-25</h3><h4 id="线性代数（花书）："><a href="#线性代数（花书）：" class="headerlink" title="线性代数（花书）："></a>线性代数（花书）：</h4><ul>
<li><p>单位矩阵 (identity matrix)：任意向量和单位矩阵相乘，都不会改变。记为 $I_n \in \mathbb{R}^{n \times n}$</p>
</li>
<li><p>矩阵的逆 (matrix inversion)：矩阵的逆和本身相乘得到单位矩阵（分左逆和右逆）, $A^{-1}A=I_n$</p>
</li>
<li><p>生成子空间 (span) : 一组向量的生成子空间是原始向量线性组合后所能抵达的点的集合</p>
</li>
<li><p>线性相关性 (linear dependence)：如果一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量就是线性无关的。</p>
</li>
<li><p>范数 (norm)：衡量一个向量的大小。 直观上来说，向量 $x$ 的范数是用来衡量从原点到 $x$ 的距离。但是更一般的说，范数是满足某些（3个）性质的任意函数（花书 $P_{24}$）。 当 $p=2$ 时，$L^2$ 范数就是欧几里得范数。</p>
</li>
</ul>
<script type="math/tex; mode=display">||x||_p = (\sum_i|x_i|^p)^{\frac{1}{p}}</script><ul>
<li><p>当机器学习问题中零和非零元素之间的差异非常重要时，通常会使用 $L^1$ 范数。这样每当 $x$ 中某个元素从 $0$ 增加 $\epsilon$ ，对应的 $L^1$ 范数也会增加 $\epsilon$。除此之外，机器学习中常用的范数还有 <strong>最大范数</strong> 和 <strong>Frobenius 范数</strong>，前者就是绝对值最大的元素，后者是用来衡量矩阵的大小。另外两个向量的点积可以用范数来表示。</p>
</li>
<li><p>特殊矩阵和向量</p>
<ul>
<li>对角矩阵 (diagonal matrix)：只有主对角线上含有非零元素，其他位置都是零。非方阵的对角矩阵没有逆矩阵，当且仅当对角元素都是非零值的时候存在对角方阵的逆矩阵。</li>
<li>对称矩阵：转置和自己相等的矩阵，即 $A=A^T$ 。举例，$A_{i,j}$ 表示点 $i$ 到点 $j$ 的距离，距离有对称性，所以矩阵 $A$ 是对称矩阵。</li>
<li>单位向量：具有单位范数的向量。</li>
<li>正交 (orghogonal)：$x^Ty=0$。如果两个向量都有非零范数，那么两个向量之间的夹角是 $90^\circ$。如果范数都为 $1$ ，那么我们称它们为标准正交 (orthonormal)。</li>
<li>正交矩阵：$A^TA=AA^T=I$，这意味着$A^{-1}=A^T$。正交矩阵收到关注的原因是求逆计算代价小。</li>
</ul>
</li>
<li><p>特征分解</p>
<ul>
<li>特征值和特征向量：$Av=\lambda v$，当且仅当含有零特征值的时候矩阵是奇异的。</li>
</ul>
</li>
<li><p>奇异值分解：目前理解不了</p>
</li>
<li><p>Moore-Penrose 伪逆：理解不了</p>
</li>
<li><p>逆运算：就是对角线元素相加，<script type="math/tex">Tr(A)=\sum_i{A_{i,i}}</script>。还有很多有趣的性质（花书 $P{29}$）。</p>
</li>
<li><p>行列式：行列式等于矩阵特征值的乘积，记作 $det(A)$。行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或者收缩了多少，如果行列式是 $0$，那么空间至少沿着某一维完全收缩了。</p>
</li>
</ul>
<h3 id="2020-05-19"><a href="#2020-05-19" class="headerlink" title="2020-05-19"></a>2020-05-19</h3><ul>
<li>经典声学建模技术 (kaldi 实战)<ul>
<li>先用 对齐 ，然后使用带标注的训练数据更新各状态对应的 GMM 的参数</li>
<li>Transition 模型<ul>
<li>transition state (音素索引，HMM状态索引，PDF索引)</li>
<li>transition id (transition-state, transition-index)</li>
</ul>
</li>
<li>音素的聚类裁剪<ul>
<li>{L}-{C}+{R}.{S}</li>
</ul>
</li>
<li>特征变换技术<ul>
<li>无监督<ul>
<li>差分（微分、Delta）</li>
<li>拼帧（Splicing）</li>
<li>归一化（Normalize / CMVN）</li>
</ul>
</li>
<li>有监督<ul>
<li>线性判别分析</li>
<li>最大似然线性变换</li>
</ul>
</li>
</ul>
</li>
<li>区分性训练<ul>
<li>核心思想：不仅要使正确路径的分数尽可能高（传统的最大似然思想），还要使错误路径，尤其是易混淆路径的分数尽可能低。比值的最大似然。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-05-12"><a href="#2020-05-12" class="headerlink" title="2020-05-12"></a>2020-05-12</h3><ul>
<li>地址无关代码<ul>
<li>fpic 和 fPIC 区别，前者限制更多，但是代码相对较小</li>
<li>如何区分一个 .so 是否为 PIC，<code>readelf -d foo.so | grep TEXTREL</code></li>
</ul>
</li>
</ul>
<h3 id="2020-05-08"><a href="#2020-05-08" class="headerlink" title="2020-05-08"></a>2020-05-08</h3><ul>
<li>链接选项 -Wl,—whole-archive 和 -Wl,—no-whole-archive</li>
</ul>
<h3 id="2020-05-07"><a href="#2020-05-07" class="headerlink" title="2020-05-07"></a>2020-05-07</h3><ul>
<li>可执行文件的装载方式<ul>
<li>覆盖装载</li>
<li>页映射</li>
</ul>
</li>
<li>进程的建立<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li>
</ul>
</li>
<li>页错误（页缺失）<ul>
<li>先找到空页所在的 VMA</li>
<li>然后得到所在可执行文件中的偏移</li>
<li>最后在物理内存中分配一个物理页，建立该物理页和虚拟页之间的映射关系。</li>
</ul>
</li>
<li>链接视图和执行试图<ul>
<li>section VS. segment</li>
</ul>
</li>
<li>堆和栈有自己的 匿名虚拟内存区域</li>
<li>段地址对齐</li>
<li>进程栈的初始化<ul>
<li>进程初始化的时候会在栈空间自动加入当前的 环境变量 和 运行参数</li>
</ul>
</li>
</ul>
<h3 id="2020-05-04"><a href="#2020-05-04" class="headerlink" title="2020-05-04"></a>2020-05-04</h3><ul>
<li>区别：make install DESTDIR=… | make install prefix=… </li>
</ul>
<h2 id="2020-04"><a href="#2020-04" class="headerlink" title="2020-04"></a>2020-04</h2><h3 id="2020-04-29"><a href="#2020-04-29" class="headerlink" title="2020-04-29"></a>2020-04-29</h3><ul>
<li>C++： <ul>
<li>左值 右值 的根本区别在于能否获取内存地址。</li>
</ul>
</li>
</ul>
<h3 id="2020-04-26"><a href="#2020-04-26" class="headerlink" title="2020-04-26"></a>2020-04-26</h3><ul>
<li>静态链接（自我修养第四章）：<ul>
<li>空间和地址分配：<ul>
<li>顺序叠加 vs. 相似段合并</li>
<li>相似段合并：<ul>
<li>第一步 扫描所有的输入目标文件，计算合并后各段长度和位置，建立映射关系</li>
<li>第二步 根据输入文件中段的数据、重定位信息，进行符号解析与重定位、调整代码中的地址</li>
</ul>
</li>
<li>链接后的程序中使用的地址已经是虚拟地址。</li>
</ul>
</li>
<li>符号解析与重定位<ul>
<li>链接器用重定位表中保存的信息对需要调整的指令做出调整</li>
<li>指令修正方式（32位x86平台下的ELF只有两种）：<ul>
<li>绝对近址32位选址（R_386_32）</li>
<li>相对近址32位选址（R_386_PC32）</li>
</ul>
</li>
</ul>
</li>
<li>COMMON 块与弱符号处理<ul>
<li>编译器为什么不直接把未初始化的全局变量也当作未初始化的局部静态变量？</li>
</ul>
</li>
<li>C++ 相关<ul>
<li>重复代码消除，例如模板、外部内联函数和虚函数表<ul>
<li>解决办法：将每个模板的实力代码都单独存在一个段里，采用相同的命名策略，这样链接器在最终链接的时候可以合并这些相同的模板实例段。</li>
<li>可能的问题：可能不同的编译单元使用不同的编译器版本或者编译优化选项，导致同一个函数编译出来的实际代码有所不同。</li>
<li>函数级别链接：把所有函数都像模板函数一样，单独保存到一个段里，只有当链接器要用到某个函数的时候才把它合并到最终文件，这样做的好处是不需要一次性合并整个代码块。这样做有好处也有坏处。</li>
</ul>
</li>
<li>全局构造和析构<ul>
<li>程序的一些特定的操作需要在 main 函数之前或者之后被执行，比如 C++ 的全局构造和析构函数。</li>
<li>ELF 文件为这两个函数定义了两个特殊的段<ul>
<li>.init</li>
<li>.fini</li>
</ul>
</li>
</ul>
</li>
<li>C++ 与 ABI (Application Binary Interface)<ul>
<li>ABI 包括那些跟可执行代码二进制兼容性有关的内容</li>
<li>ABI vs. API：前者更严格，关注二进制层面的接口，后者只关注源代码层面的接口。以 printf 这个方法为例，不同操作系统和平台上都提供了 printf 这个函数（API 相同），但是他们的二进制实现方式却不尽相同（ABI 不同）。</li>
</ul>
</li>
</ul>
</li>
<li>为什么很多静态库里面一个目标文件只包含一个函数？比如 libc.a 里面 printf.o 只有 printf() 函数、strlen.o 只有 strlen() 函数。<ul>
<li>这些函数会经常被用到，就是经常会被链接，如果很多函数都放在同一个目标文件中，很可能很多没用的函数被一起链接到输出文件中。（其实可以用前面提到的函数级别链接解决，但是也有代价）</li>
</ul>
</li>
<li>我们可以用自己写的链接控制脚本来控制链接过程（比如输出特定名字的段，而不是默认的 ELF 文件段结构）</li>
<li>BFD 库 (Binary File Descriptor library)<ul>
<li>把编译器/链接器和具体的目标文件格式隔离开，实现跨平台的效果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-04-23"><a href="#2020-04-23" class="headerlink" title="2020-04-23"></a>2020-04-23</h3><ul>
<li><p>线性代数——李弘毅：</p>
<ul>
<li><p>Linear System:</p>
<ul>
<li><p>Two properties:</p>
<ol>
<li>Persevering  Multiplication</li>
<li>Persevering Addition</li>
</ol>
<img src="https://hepsia.db.files.1drv.com/y4mx_T6o_-ZGHXj-IHnxItAQkNOSYQd7fkiu0oOAqejCTzMjO3AwIp4eE21yE8SKEJKYxfZQuQ3mmzVTRurPuXhp024cQNepuU2uXqFqh4qcOWrPj_d8dEuyjSvKp23yjMBX6MUCwKhJEy-kPghFS97LnPsztAZUCej0u_sN2iJrBOSyU2e8eBaD-D17PCl56Su1bQRI27aYpQHiYAPVRriRw?width=660&height=448&cropmode=none"> 
</li>
</ul>
</li>
<li><p>Application</p>
<ul>
<li>Page Rank </li>
<li>computer graphic</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-04-22"><a href="#2020-04-22" class="headerlink" title="2020-04-22"></a>2020-04-22</h3><ul>
<li>c/c++ 目标文件里有什么 （自我修养第三章）：<ol>
<li>目标文件的格式: PE / ELF, 他们都是 COFF 格式的变种</li>
<li>目标文件是什么样的：各种段（segment）或叫做节（section）<ol>
<li>代码段</li>
<li>（只读）数据段</li>
<li>BSS段</li>
<li>其他段</li>
</ol>
</li>
<li>ELF 文件结构<ol>
<li>文件头</li>
<li>段表</li>
<li>重定位表</li>
<li>字符串表</li>
</ol>
</li>
<li>链接的接口——符号<ol>
<li>符号表的结构。包括符号名，符号值，符号大小，符号类型和绑定信息，所在的段。</li>
<li>特殊符号：当使用 ld 作为连接器来链接出可执行文件时，它自己会定义很多特殊符号，这些符号虽然没有在程序里面定义，但是我们可以直接在代码中声明并使用他们。都是一些程序起始或者结束的地址信息，一般用不到。</li>
</ol>
</li>
<li>符号修饰和函数签名<ol>
<li>函数签名和修饰后符号之间的对应关系</li>
<li>extern “C”<ol>
<li>代码中可以直接用 extern “C” 声明一个变量的修饰后名称，并用这个变量名来直接操作。</li>
<li>extern “C” 还用于 C 和 C++ 的混编。</li>
</ol>
</li>
<li>强符号与弱符号，强引用与弱引用<ol>
<li>未初始化的全局变量为弱符号，也可以用 <strong>attribute</strong>((week)) 来定义任何一个强符号为弱符号</li>
<li>对于被多次定义的全局符号，链接器在工作时有一套覆盖规则（P92）</li>
<li>对于没有定义的强引用，链接器会认为是一个错误，但是对于弱引用，编译器不认为是一个错误。</li>
<li>弱引用跟链接器的 COMMON 块概念联系很紧密。</li>
<li>思考弱引用和弱符号在实际使用中的作用。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="2020-04-16"><a href="#2020-04-16" class="headerlink" title="2020-04-16"></a>2020-04-16</h3><ul>
<li>C 语言链接时的接口——符号<ul>
<li>符号（symbol）即源代码中函数和变量的统称，函数名和变量名就是符号名。</li>
<li>符号可以看作是链接中的粘合剂。</li>
</ul>
</li>
</ul>
<h3 id="2020-04-15"><a href="#2020-04-15" class="headerlink" title="2020-04-15"></a>2020-04-15</h3><ul>
<li>git 丢弃未提交的本地修改： <code>git checkout .</code>; 撤销暂存区的修改：<code>git reset</code></li>
</ul>
<h3 id="2020-04-09"><a href="#2020-04-09" class="headerlink" title="2020-04-09"></a>2020-04-09</h3><ul>
<li><p>C \ C++ 中的 ‘\377’</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMzkwNjM2NQ==&amp;mid=2247484816&amp;idx=1&amp;sn=fac6a68a4a51d79f4774558e64ffd98e&amp;chksm=97aee342a0d96a546cc0c4b2e6309587a0e95ca6be1d523d4d32aa01dd2e2c9f6234e0a7ba0e&amp;scene=126&amp;sessionid=1586401199&amp;key=dd536dadd64dbc3ec3691d0bd982c39b24880bb00587833737f600d733df5acb99404fc717e2e063aa101a1135d4f3f16964ccab0aef64db4f7409e0caa57e08e63c792a08edb2bb3e6d105d56698a98&amp;ascene=1&amp;uin=MTU3MTgzNjI4Mg%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=AZ9sy%2BUusfYkFd%2BESWSNW8Q%3D&amp;pass_ticket=EqxqBU%2FUdl%2BxvkTDBFBfmrXaN1enHx2D89BVnuKHWOgOKH6rlMBJwzs%2B9PjsbCtp" target="_blank" rel="noopener">LDA (Latent Dirichlet Allocation)</a>:</p>
<ul>
<li>二项分布就是对伯努利分布重复n次</li>
<li>Beta 分布、二项分布、Dirichlet 分布、多项式分布：<ul>
<li>Beta 分布是二项式分布的共轭先验分布</li>
<li>Dirichlet 分布是多项式分布的共轭分布</li>
</ul>
</li>
<li>两种近似推断方法<ul>
<li>采样、sampling</li>
<li>变分推断、variational inference</li>
</ul>
</li>
<li>LDA 是 pLSA 的贝叶斯化版本</li>
</ul>
</li>
</ul>
<h3 id="2020-04-08"><a href="#2020-04-08" class="headerlink" title="2020-04-08"></a>2020-04-08</h3><ul>
<li>x86 -&gt; ARMv8 （linux）交叉编译器默认的 char 是 unsigned char。以后用 char 类型传递数值时要先判断编译器的默认 char 类型。</li>
</ul>
<h3 id="2020-04-07"><a href="#2020-04-07" class="headerlink" title="2020-04-07"></a>2020-04-07</h3><ul>
<li><p>kaldi::ReadBasicType<t>() 报错 …file position is -1…</t></p>
</li>
<li><p>gdb 调式命令</p>
</li>
</ul>
<h3 id="2020-04-03"><a href="#2020-04-03" class="headerlink" title="2020-04-03"></a>2020-04-03</h3><ul>
<li><a href="https://cmake.org/pipermail/cmake/2016-May/063400.html" target="_blank" rel="noopener">Difference between PRIVATE and PUBLIC with target_link_libraries</a></li>
<li>linux 下一般程序运行时查找动态库的顺序：<ul>
<li>环境变量 LD_LIBRARY_PATH 指定的路径</li>
<li>根据 /etc/ld.so.cache 查找</li>
<li>/lib 和 /usr/lib 目录查找</li>
</ul>
</li>
</ul>
<h2 id="2020-03"><a href="#2020-03" class="headerlink" title="2020-03"></a>2020-03</h2><h3 id="2020-03-25"><a href="#2020-03-25" class="headerlink" title="2020-03-25"></a>2020-03-25</h3><ul>
<li>linux 交叉编译 openfst（1.6.7）:<ul>
<li><code>./configure CXX=aarch64-linux-gnu-g++ --host=armv8 --prefix=</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>pc 平台流行的可执行程序：</p>
<ul>
<li>Windows 下的 PE (portable executable)</li>
<li>Linux 下的 ELF (executable linkable format)</li>
<li>他们都是 COFF (common file format) 的变种</li>
</ul>
</li>
<li><p>可执行文件内部结构：</p>
<ul>
<li>代码段（Code Section）和数据段（Data Section）</li>
</ul>
</li>
</ul>
<h3 id="2020-03-24"><a href="#2020-03-24" class="headerlink" title="2020-03-24"></a>2020-03-24</h3><blockquote>
<div title="有关的; 中肯的; 恰当的"> pertinent </div>


</blockquote>
<ul>
<li>linux 命令：<ul>
<li>vim 中搜索：<ul>
<li>normal 模式下输入<code>/</code></li>
<li><code>n</code> 查找下一个；<code>N</code> 查找上一个</li>
<li>支持正则查找</li>
<li>后加 <code>\C</code>，大小写敏感；<code>\c</code> 不敏感</li>
<li>normal 模式下按 <code>*</code> 即可查找光标所在单词</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-03-23"><a href="#2020-03-23" class="headerlink" title="2020-03-23"></a>2020-03-23</h3><ul>
<li>linux 交叉编译 openBLAS（0.3.9）: <code>make TARGET=ARMV8 BINARY=64 HOSTCC=gcc CC=aarch64-linux-gnu-gcc NOFORTRAN=1</code><ul>
<li>如果要用 gfortran 的话记得版本要和gcc对应，不然动态库编译不过</li>
<li>可能的报错： <code>*** No rule to make target &#39;../kernel/arm/amax.S&#39;, needed by &#39;samax_k.o&#39;.  Stop.</code> ，可能原因是用了32位的编译工具</li>
</ul>
</li>
</ul>
<ul>
<li><p>linux 命令：</p>
<ul>
<li>tar:<ul>
<li><code>tar -czvf</code> 压缩</li>
<li><code>tar -xzvf</code> 解压</li>
</ul>
</li>
<li>shell 快捷键：<ul>
<li><code>ctrl - r</code> 查找历史命令 </li>
<li><code>ctrl - b/f</code> 前/后移动一个字符</li>
<li><code>alt - b/f</code> 前/后移动一个单词</li>
<li><code>ctrl - a/e</code> 移动到首/尾</li>
<li><code>ctrl - u/k</code> 删除光标左/右边所有</li>
<li><code>ctrl - l</code> 清屏</li>
</ul>
</li>
</ul>
</li>
<li><p>git 如何创建一个新分支:</p>
<ul>
<li><code>git checkout --orphan branch_name</code></li>
<li>然后吧原分支的文件都输出掉就可以了。</li>
</ul>
</li>
</ul>
<ul>
<li>世界上最远的距离是知道和做到。</li>
</ul>
<h3 id="2020-03-18"><a href="#2020-03-18" class="headerlink" title="2020-03-18"></a>2020-03-18</h3><ul>
<li>C++:<ul>
<li>构造函数后面用冒号初始化和在构造函数里面对成员进行赋值的区别</li>
<li>const 类型和引用不可以被赋值</li>
</ul>
</li>
</ul>
<ul>
<li>链接过程(p 51)：<ul>
<li>Address and Storage Allocation</li>
<li>Symbol Resolution</li>
<li>Relocation</li>
</ul>
</li>
</ul>
<h3 id="2020-03-17"><a href="#2020-03-17" class="headerlink" title="2020-03-17"></a>2020-03-17</h3><ul>
<li>ASR 数据集：<ul>
<li>TIMIT(4h)</li>
<li>WSJ (8h)</li>
<li>Switchboard (300h)</li>
<li>Librispeech (960h)</li>
<li>Fisher (2000h)</li>
</ul>
</li>
</ul>
<ul>
<li>编译过程（6步，p42）：<ul>
<li>扫描（词法分析）-lex</li>
<li>语法分析 - yacc(Yet Another Compiler Compiler)</li>
<li>语义分析 - 静态语义，声明和类型得匹配、类型得转换</li>
<li>源代码优化 - intermediate code (Three-address Code / P-Code)</li>
<li>代码生成</li>
<li>目标代码优化</li>
</ul>
</li>
</ul>
<h3 id="2020-03-11"><a href="#2020-03-11" class="headerlink" title="2020-03-11"></a>2020-03-11</h3><ul>
<li>C 程序编译<ul>
<li>当无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</li>
</ul>
</li>
</ul>
<h3 id="2020-03-10"><a href="#2020-03-10" class="headerlink" title="2020-03-10"></a>2020-03-10</h3><ul>
<li><p>vim 查看16进制的为解码内容：</p>
<ul>
<li>vim -b filename</li>
<li>:%!xxd</li>
</ul>
</li>
<li><p>从源代码到可执行文件的4个步骤（p38）：</p>
<ul>
<li>Preprossing</li>
<li>Compilation</li>
<li>Assembly</li>
<li>Linking</li>
</ul>
</li>
</ul>
<h3 id="2020-03-04"><a href="#2020-03-04" class="headerlink" title="2020-03-04"></a>2020-03-04</h3><ul>
<li>C++:<ul>
<li>编译相关的文件后缀<ul>
<li>Windows：.lib  .dll  .obj</li>
<li>Linux: .a  .so  .o</li>
<li>静态库其实就是很多目标文件的打包集合体，因此在一个工程中导入一个项目的静态库和导入该项目的源代码没什么区别（前提是编译环境一致）。</li>
</ul>
</li>
<li>代码风格<ul>
<li>所有if都要用 {}，便于以后阅读。</li>
<li>不要在同一行中声明多个变量</li>
<li>所有临时变量都需要在声明时进行赋值</li>
<li>二元运算符在哪里都需要两边空格</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Linux 命令： ar<ul>
<li>库函数操作命令</li>
</ul>
</li>
</ul>
<h2 id="2020-02"><a href="#2020-02" class="headerlink" title="2020-02"></a>2020-02</h2><h3 id="2020-02-26"><a href="#2020-02-26" class="headerlink" title="2020-02-26"></a>2020-02-26</h3><ul>
<li>英语中的介词：<ul>
<li>on vs. in<ul>
<li>on.1 一物以另一物为支撑或载体<ul>
<li>It’s not easy to skate on one foot.</li>
<li>The man climbed down on a rope.</li>
<li>Dinner is on me tonight.</li>
</ul>
</li>
<li>on.2 一物以另一物为工具<ul>
<li>On the bus.</li>
<li>He’s shouting on the intercome.</li>
</ul>
</li>
<li>on.3 表示动作、行为、食事物所指向的对象<ul>
<li>She’s cheating on me.</li>
<li>Work on your interview skills.</li>
<li>Keep an eye on the baby.</li>
</ul>
</li>
<li>on.4 表示某事正在发生或在发生的过程中<ul>
<li>On sale.</li>
<li>On a rool. (连续交好运)</li>
<li>He is on a coffee break.</li>
<li>On my way home.</li>
</ul>
</li>
<li>in.1 某事发生在某个范围之内（不超出某个范围）<ul>
<li>He’ll be with you in five minutes.</li>
<li>She ripped the sheet of paper in two.</li>
</ul>
</li>
<li>in.2 一物是另一物的组成部分<ul>
<li>We’ve made a couple of changes in your schedule.</li>
<li>She’s everything I’d want in a wife.</li>
</ul>
</li>
<li>in.3 浸泡在某物中，受某物影响<ul>
<li>I’m in a hurry.</li>
<li>You’re in a big trouble.</li>
<li>He asked in surprise</li>
</ul>
</li>
<li>in.4 以某种方式<ul>
<li>She spoke in a low whisper.</li>
<li>I had to speak to him in French.</li>
<li>Do not write in pencil on this test.</li>
</ul>
</li>
</ul>
</li>
<li>over<ul>
<li><ol>
<li>结束</li>
</ol>
</li>
<li><ol>
<li>覆盖</li>
</ol>
<ul>
<li>I put another blanket over the baby.</li>
<li>I’ve been looking all over for you.</li>
</ul>
</li>
<li><ol>
<li>从某一点到另一点</li>
</ol>
<ul>
<li>Over here!</li>
<li>I come over to help.</li>
<li>I’d prefer to talk about it over the phone.</li>
</ul>
</li>
<li><ol>
<li>胜过、超过、优于</li>
</ol>
<ul>
<li>The game is designed for children over 6 yours old.</li>
<li>I’m so over men. (我看透男人了。)</li>
<li>That would’ve put him over the edge.(这会把他逼急的)</li>
</ul>
</li>
</ul>
</li>
<li>off<ul>
<li>脱离、离开，可衍生为“一个事物脱离原来的位置或状态”<ul>
<li>Get your feet off my couch.</li>
<li>I finally take this picture off the wall.</li>
<li>It pissed me off. (脱离了原来平静的状态，变得生气了)</li>
<li>Get your hands off me.</li>
<li>Joe was clearly relieved to be off the topic of his ex-firlfriend.  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-02-25"><a href="#2020-02-25" class="headerlink" title="2020-02-25"></a>2020-02-25</h3><ul>
<li>C++<ul>
<li>inline（内联函数），以内存空间换运行效率</li>
<li>模板的实例化和调用都可以分显式和隐式（但模板类没有显式调用）</li>
<li>模板实例化的好处</li>
<li>函数模板特化和函数重载，不同之处：<ul>
<li>模板有“惰性实例化”的特性</li>
<li>重载函数使用起来更麻烦，需要在各个源文件中包含重载函数的申明</li>
</ul>
</li>
<li>过度优化</li>
</ul>
</li>
</ul>
<h3 id="2020-02-23"><a href="#2020-02-23" class="headerlink" title="2020-02-23"></a>2020-02-23</h3><ul>
<li>C++<ul>
<li>父类子类指针的函数调用的注意事项（三点）。虚拟函数就是为了对“如果你以一个基础类指针指向一个衍生类对象，那么通过该指针，你只能访问基础类定义的成员函数”这条规则反其道而行之的设计。</li>
<li>explicit 关键字</li>
<li>#define 定制自己的日志输出符号</li>
</ul>
</li>
</ul>
<h3 id="2020-02-22"><a href="#2020-02-22" class="headerlink" title="2020-02-22"></a>2020-02-22</h3><ul>
<li>英语思维：<ul>
<li>语言的掌握是一种心理认知的过程，传统教学把则把语言当成一种普通的知识灌输</li>
<li>体验是语言生成的途径，体验是用来建立语言和现实生活中的联系</li>
<li>构建自己的词汇网络</li>
<li>英语在表述上之所以比汉语更加客观、更加具有实质性，而汉语更加从自己的主观感觉出发。</li>
</ul>
</li>
</ul>
<ul>
<li>C++:<ul>
<li>纯虚函数<ul>
<li>所在的类不能被实例化</li>
<li>这个方法必须在派生类中被实现</li>
</ul>
</li>
<li>返回指针和引用</li>
</ul>
</li>
</ul>
<h3 id="2020-02-21"><a href="#2020-02-21" class="headerlink" title="2020-02-21"></a>2020-02-21</h3><ul>
<li>模板的实例化 length_norm</li>
<li>plda 效率问题</li>
<li>xvector.cpp -&gt; k_extract_xvector_from_feature（）里面的流程</li>
<li>resource-manager  engine-interface 怎么耦合在一起</li>
<li>log的流程，为什么用这么多宏命令</li>
</ul>
<h3 id="2020-02-20"><a href="#2020-02-20" class="headerlink" title="2020-02-20"></a>2020-02-20</h3><ul>
<li><p>ctc-loss, WER/LER</p>
</li>
<li><p>香辣小土豆：</p>
<ul>
<li>要用蒸的</li>
</ul>
</li>
</ul>
<h3 id="2020-02-15"><a href="#2020-02-15" class="headerlink" title="2020-02-15"></a>2020-02-15</h3><blockquote>
<div title="失真"> distortion </div>


</blockquote>
<h3 id="2020-02-11"><a href="#2020-02-11" class="headerlink" title="2020-02-11"></a>2020-02-11</h3><ul>
<li><p>C++:</p>
<ul>
<li><p><a href="https://www.cnblogs.com/flylong0204/p/4731318.html" target="_blank" rel="noopener">C++ 类对象和类指针的区别</a></p>
</li>
<li><p>C++ 类成员两种“初始化”方式（构造函数后面冒号 或 在构造函数里面赋值）的区别</p>
</li>
<li><p>函数后面用 const 修饰</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>炒土豆片的时候记得焖一会儿</li>
</ul>
<h3 id="2020-02-10"><a href="#2020-02-10" class="headerlink" title="2020-02-10"></a>2020-02-10</h3><ul>
<li>git 删除分支：git branch —d guoxia-dev 和 git branch —D guoxia-dev 的区别</li>
</ul>
<h3 id="2020-02-07"><a href="#2020-02-07" class="headerlink" title="2020-02-07"></a>2020-02-07</h3><ul>
<li>炒牛肉片的技巧：<ul>
<li>牛肉筋络多的地方适合做大块的牛肉，比如红烧牛肉和土豆牛肉；筋络少的做炒肉片</li>
<li>切断纹路</li>
<li>盐水泡15分钟</li>
<li>用水淀粉包裹</li>
<li>先只炒一分钟（热锅凉油）</li>
<li>小苏打（保持嫩滑），白胡椒（去腥），老抽（上色），淀粉加水，油（炒的时候不粘）</li>
<li>辣椒，姜片，洋葱，肉片，最后放青椒</li>
</ul>
</li>
</ul>
<h3 id="2020-02-06"><a href="#2020-02-06" class="headerlink" title="2020-02-06"></a>2020-02-06</h3><ul>
<li>grep 命令的常用参数：<ul>
<li>-c: 只输出匹配行的行数。</li>
<li>-h: 查询多文件时不显示文件名。</li>
<li>-I: 不区分大小写（只适用于单字符）。</li>
<li>-n: 显示匹配的行和行号。</li>
<li>-s: 不显示 不存在或无匹配文本 的错误信息。</li>
<li>-v: 反向匹配，即显示不包含匹配文本的所有行。</li>
<li>-R: 递归查询，即连同子目录中的文件一起查询。</li>
</ul>
</li>
</ul>
<h3 id="2020-02-04"><a href="#2020-02-04" class="headerlink" title="2020-02-04"></a>2020-02-04</h3><ul>
<li><p>c++ 的枚举类型</p>
</li>
<li><p>bash shell常用快捷键：</p>
<ul>
<li><code>ctrl + l</code> ：清屏</li>
<li><code>ctrl + r</code> ：搜索</li>
<li><code>alt + b/f</code> ： 回退/前进 一个单词</li>
</ul>
</li>
<li><p><code>git add .</code> 和 <code>git add -u</code> 还有 <code>git add -A</code> 的区别</p>
</li>
<li>git 项目迁移</li>
</ul>
<h2 id="2020-01"><a href="#2020-01" class="headerlink" title="2020-01"></a>2020-01</h2><h3 id="2020-01-21"><a href="#2020-01-21" class="headerlink" title="2020-01-21"></a>2020-01-21</h3><blockquote>
<div title="不断前进的，又进展的"> progressive </div>

</blockquote>
<h3 id="2020-01-19"><a href="#2020-01-19" class="headerlink" title="2020-01-19"></a>2020-01-19</h3><blockquote>
<div title="发声，表达，说话方式"> utterance </div>
<div title="静止的，不动的"> stationary </div>

</blockquote>
<ul>
<li>声音三要数：<ul>
<li>响度/振幅</li>
<li>音高/频率</li>
<li>音色/相位</li>
<li>以上都不是线性相关关系，因为人耳的的听觉特征并非完全线性。                                                                                                     </li>
</ul>
</li>
<li>c 程序的编译过程:<ul>
<li>预处理：宏替换、头文件包含内容替换</li>
<li>编译：预处理后的源文件转换成汇编代码</li>
<li>汇编：汇编代码转换成二进制文件（中间文件）</li>
<li>链接：将各个中间文件链接到一起，生成可执行文件                                                                                                                                                                                                      </li>
</ul>
</li>
</ul>
<h3 id="2020-01-15"><a href="#2020-01-15" class="headerlink" title="2020-01-15"></a>2020-01-15</h3><ul>
<li><p>linux 命令：</p>
<ul>
<li>eval: 可以将命令里面的引用替换掉（两次扫描）</li>
<li>vim 查找：<code>/要查找的内容</code>， 后面带 <code>\c</code> 表示大小写不敏感，<code>\C</code> 反之</li>
</ul>
</li>
<li><p>python:</p>
<ul>
<li>调用 linux 系统命令：<ul>
<li>os.system / os.popen()</li>
<li>subprocess.Popen()</li>
</ul>
</li>
<li>终止程序：<ul>
<li>os._exit()：直接终止</li>
<li>sys.exit()：抛出异常(SystemExit)</li>
</ul>
</li>
</ul>
</li>
<li><p>Markdown 行内代码用单点，代码块用三个点。</p>
</li>
</ul>
<h3 id="2020-01-13"><a href="#2020-01-13" class="headerlink" title="2020-01-13"></a>2020-01-13</h3><ul>
<li>git:<ul>
<li>git config —global push.default matching/simple:<ul>
<li>matching 表示 push 的时候push所有已存在的同名分支到远程仓库</li>
<li>simple 表示只 push 当前所在的分支</li>
<li>git 2.0 以前默认是matching，2.0 以后默认变成了simple</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-01-09"><a href="#2020-01-09" class="headerlink" title="2020-01-09"></a>2020-01-09</h3><ul>
<li>C/C++语法：<ul>
<li>void* 做返回值表示该函数可以表示任意类型的指针</li>
<li>C语言中的static关键字可以修饰变量和函数，其作用都是使其修饰的东西仅在当前文件中有用，如果static修饰函数中的局部变量则表示该变量的作用域只是当前函数。static的该功能可以被匿名命名空间取代。在C++中static有了不同的用法，所以推荐用匿名空间来做作用域的控制。</li>
<li>extern 关键字： 告诉编译器该变量是存在的，但不是在该文件当前位置之前声明的，去别的地方应该能找到（可能是该文件当前位置的后面，也可能是在别的文件）。</li>
</ul>
</li>
</ul>
<h3 id="2020-01-08"><a href="#2020-01-08" class="headerlink" title="2020-01-08"></a>2020-01-08</h3><ul>
<li>Linux 命令行结果写入到文件用 <code>&gt;</code></li>
</ul>
<h3 id="2020-01-07-1"><a href="#2020-01-07-1" class="headerlink" title="2020-01-07"></a>2020-01-07</h3><ul>
<li>conda 命令：<ul>
<li>添加源： conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</a></li>
<li>conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a></li>
<li>conda config —set show_channel_urls yes</li>
<li>删除添加的源： conda config —remove-key channels</li>
<li>conda config —remove channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</a></li>
</ul>
</li>
</ul>
<h3 id="2020-01-06"><a href="#2020-01-06" class="headerlink" title="2020-01-06"></a>2020-01-06</h3><ul>
<li>C++语法：<ul>
<li>#include 后面用&lt;&gt;,和用“”的区别</li>
<li>引用 vs. 指针<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到不同对象</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
<li>指针传递参数的本质还是值传递（形参是实参的一个副本），就是这个“值”变成了一个地址。</li>
<li>指针在逻辑上是独立的，他只是一个普通的变量，只是这个变量的值是一个地址（而不是别的数据类型，如int）；引用在逻辑上不是独立的，它的存在具有依附性，所有引用必须在声明的时候初始化，且之后不能引用别的对象。</li>
</ul>
</li>
<li>const 用法<ul>
<li>修饰普通变量</li>
<li>修饰指针变量</li>
<li>参数传递和函数返回值</li>
<li>修饰成员函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2020-01-03"><a href="#2020-01-03" class="headerlink" title="2020-01-03"></a>2020-01-03</h3><ul>
<li><p>Linux 命令：</p>
<ul>
<li>pwd : 查看当前路径</li>
<li>df : 察看硬盘信息<ul>
<li>-h: 让各个数字变得可读性更高，例如把1021个字节写出1k。</li>
</ul>
</li>
</ul>
</li>
<li><p>gcc - make - makefile - CMake</p>
</li>
</ul>
<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><h2 id="2019-12"><a href="#2019-12" class="headerlink" title="2019-12"></a>2019-12</h2><h3 id="2019-12-19"><a href="#2019-12-19" class="headerlink" title="2019-12-19"></a>2019-12-19</h3><blockquote>
<div title="荒谬的；荒诞"> absurd </div>
<div title="有形的；可触摸的"> tangible </div>
<div title="自满的；沾沾自喜的"> smug </div>
<div title="使迷惑；使糊涂"> confound </div>
<div title="很小的；小小的"> teeny </div>
<div title="不合理的；无理数"> irrational </div>
<div title="芥末"> mustard </div>
<div title="结语；收场白"> epilogue </div>


</blockquote>
<ul>
<li><a href="https://betterexplained.com/articles/a-visual-intuitive-guide-to-imaginary-numbers/" target="_blank" rel="noopener">A Visual, Intuitive Guide to Imaginary Numbers</a><ul>
<li>Really Understanding Negative Numbers<ul>
<li>Negatives were considered absurd in the 1700s.</li>
</ul>
</li>
<li>Enter Imaginary Numbers<ul>
<li>Imaginary numbers are a tool to describe the world, which are as normal as every other number.</li>
<li>$i^2 = -1$</li>
</ul>
</li>
<li>Visual Understanding of Negative And Complex Numbers<ul>
<li>$1\cdot x \cdot x = -1$ : What transformation x, when applied twice, turn 1 into -1?</li>
<li>rotation</li>
<li>Numbers are 2-dimensional<ul>
<li>$i$ is a “new imaginary dimension” to measure a number</li>
<li>$i$ (or $-i$) is what numbers “become” when rotated</li>
<li>Multiplying $i$ is a rotation by 90 degrees counter-clockwise, multiplying by $-i$ is a rotation by 90 degrees clockwise</li>
<li>Two rotations in eigher direction is -1: it brings us back into the “regular” dimensions of positive and negative numbers.</li>
</ul>
</li>
</ul>
</li>
<li>Finding Patterns<ul>
<li>negative numbers: 1,-1,1,-1,1…</li>
<li>imaginary numbers: 1,$i$,-1,-$i$,1…</li>
</ul>
</li>
<li>Understanding Complex Numbers<ul>
<li>how “big” is a complex number?   <ul>
<li>Size of $a + bi = \sqrt{a^2+b^2}$ </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-12-18"><a href="#2019-12-18" class="headerlink" title="2019-12-18"></a>2019-12-18</h3><ul>
<li>尤克里里：<ul>
<li>几弦几品，有些不同的地方能发出一样的声音</li>
<li>控制拨弦力度统一</li>
<li>1-A，2-E，3-C，4-G</li>
</ul>
</li>
</ul>
<h2 id="2019-11"><a href="#2019-11" class="headerlink" title="2019-11"></a>2019-11</h2><h3 id="2019-11-25"><a href="#2019-11-25" class="headerlink" title="2019-11-25"></a>2019-11-25</h3><ul>
<li><p>Expectation-Maximization, EM 算法的简单情况可以用三硬币模型来理解。</p>
</li>
<li><p>HMM 模型的3个基本问题：</p>
<ul>
<li>概率计算问题</li>
<li>学习问题</li>
<li>预测问题</li>
</ul>
</li>
</ul>
<h3 id="2019-11-21"><a href="#2019-11-21" class="headerlink" title="2019-11-21"></a>2019-11-21</h3><ul>
<li>Blog: <a href="https://medium.com/stellargraph/knowing-your-neighbours-machine-learning-on-graphs-9b7c3d0d5896" target="_blank" rel="noopener">Machine Learning on Graphs</a><ul>
<li>Types of networks<ul>
<li>Homogeneous VS. Heterogeneous</li>
<li>Static VS. Dynamic</li>
</ul>
</li>
<li>What can we learn from graphs<ul>
<li>Node Classification, also know as node attribute inference</li>
<li>Link Prediction</li>
<li>Community Detection</li>
<li>Graph Classification</li>
</ul>
</li>
</ul>
</li>
<li>tensorflow, static_rnn 和 dynamic_rnn 区别<ul>
<li>static_rnn 是把RNN展开，复制固定数量的 RNNCell；而 dynamic_rnn 是用while循环</li>
<li>因此，输入到静态 RNN 的序列长度必须完全相同；而动态的 RNN 不同 batch 之间的序列长度可以不同，但是同一个 batch 里长度必须相同。</li>
<li>static_rnn 接受的是大小为 &lt;序列长度, batchSize, 词向量大小&gt; 的 tensor; 而 dynamic_rnn 接受的是大小为 <batchsize，序列长度，词向量大小> 的 tensor</batchsize，序列长度，词向量大小></li>
</ul>
</li>
</ul>
<h3 id="2019-11-20"><a href="#2019-11-20" class="headerlink" title="2019-11-20"></a>2019-11-20</h3><blockquote>
<div title="兜帽"> hood </div>



</blockquote>
<ul>
<li><p>Python 生成器只能遍历一遍，它也实现了迭代协议，可以说是一种特殊的迭代器。</p>
</li>
<li><p>Python 多进程和多线程：</p>
<ul>
<li>由于GIL，Python 的多线程同时只能有一个线程占用CPU。</li>
<li>多线程用 threading.Thread()；多进程用 multiprocessing.Process()</li>
<li>CPU 密集型程序用多进程；I/O 密集型程序用多线程</li>
</ul>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/92017824" target="_blank" rel="noopener">浅谈 Transformer-based 模型中的位置表示</a></p>
<ul>
<li>原始 Transformer 使用如下公式生成固定的位置表示<ul>
<li><script type="math/tex; mode=display">PE(pos, 2i) = sin(\frac{pos}{10000^{2i/d_{model}}})</script></li>
<li><script type="math/tex; mode=display">PE(pos, 2i+1) = cos(\frac{pos}{10000^{2i/d_{model}}})</script></li>
<li>使用这个公式的原因，作者表示,用这个公式可以表示出不同位置的词之间的相对位置信息，因为 $PE_{p+k}$ 可以由 $PE_p$ 的线性方程表示”</li>
<li>但是，这个方法得到的位置信息表示没有方向性；而且这个性质会被 self-attention 机制破坏。</li>
<li><img src="/2019/02/13/everyday-note/positon-embedding-1.jpg" title="两个不同位置的表示向量的乘积和偏移量k之间的关系"></li>
<li><img src="/2019/02/13/everyday-note/position-embedding-2.jpg" title="经过自注意力层的KQV映射之后，上述位置信息会被破坏"></li>
</ul>
</li>
<li>后面的BERT和一些相关的模型没有用上述的固定的位置信息表示，而是采用了所谓的 “learned and fixed” 的可学习的位置嵌入，就说训练一个位置嵌入矩阵，大小为 $L_{max} \times d$</li>
<li>相对位置表示（Relative Position Representations, RPR）<ul>
<li>RNN 依靠其循环机制，结合 $t$ 时刻的输入和前一时刻的隐藏层状态 $h_{t-1}$ 计算出 $h_t$, 直接通过其顺序结构沿时间维度捕捉相对和绝对位置；而非RNN模型不需要顺序处理输入，则需要显式编码才能引入位置信息。</li>
<li>原 transformer 中的 Self-attention 机制如下</li>
<li><script type="math/tex; mode=display">e_{ij} = \frac{x_i W^Q(x_jW^K)^T}{\sqrt{d_k}}</script></li>
<li><script type="math/tex; mode=display">\alpha_{ij} = \frac{exp(e_{ij})}{\sum_{k=1}^{n}exp(e_{ik})}</script></li>
<li><script type="math/tex; mode=display">z_i = \sum_{j=1}^{n}\alpha_{ij}(x_jW^V)</script></li>
<li>RPR 不在输入时将位置嵌入与词嵌入向量相加，而是选择对上述 Self-attention 进行改动：</li>
<li><script type="math/tex; mode=display">e_{ij} = \frac{x_i W^Q(x_jW^K + a_{ij}^K)^T}{\sqrt{d_k}}</script></li>
<li><script type="math/tex; mode=display">\alpha_{ij} = \frac{exp(e_{ij})}{\sum_{k=1}^{n}exp(e_{ik})}</script></li>
<li><script type="math/tex; mode=display">z_i = \sum_{j=1}^{n}\alpha_{ij}(x_jW^V + a_{ij}^V)</script></li>
<li>其中 $a_{ij}^{K,V}$ (不是 $\alpha$) 的计算方式如下：</li>
<li><script type="math/tex; mode=display">a_{ij}^K = w_{clip(j-i,k)}^K</script></li>
<li><script type="math/tex; mode=display">a_{ij}^V = w_{clip(j-i,k)}^V</script></li>
<li><script type="math/tex; mode=display">clip(j-u,k) = max(-k, min(K,x))</script></li>
<li>如此，模型需要学习的就说相对位置表示 $w^K = (w_{-k}^K,…,w_k^K)\in \mathbb{R}^{(2k+1)\times d}$ ，同一层的 attention heads 之间共享，但是在不同层之间是不同的。</li>
<li>不过，论文在对机器翻译任务进行效率实验时发现，$a_{ij}^V$ 可能不是必要的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-11-19"><a href="#2019-11-19" class="headerlink" title="2019-11-19"></a>2019-11-19</h3><blockquote>
<div title="求导"> differentiate </div>
<div title="导数"> derivative </div>


</blockquote>
<ul>
<li><p><a href="https://towardsdatascience.com/an-intuitive-understanding-of-the-lamb-optimizer-46f8c0ae4866" target="_blank" rel="noopener">An intuitive understanding of the LAMB optimizer</a></p>
<ul>
<li><p>Adam:</p>
<ul>
<li>Keep a moving average of the gradients and their variance:  </li>
<li><script type="math/tex; mode=display">m^{(t-1)}_w \leftarrow \beta_1 m^{(t)}_w + (1-\beta_1)\nabla_w L^{(t)}</script></li>
<li><script type="math/tex; mode=display">v^{(t-1)}_w \leftarrow \beta_2 v^{(t)}_w + (1-\beta_2)(\nabla_w L^{(t)})^2</script></li>
<li>A visualization of how much smoothing we get on a noisy dataset for different betas.<ul>
<li>small batch - the gradient might be noisier - higher $\beta$</li>
<li>large batch - less noise - less $\beta$<div style="width:70%"><img src="/2019/02/13/everyday-note/moving-average.png"></div></li>
</ul>
</li>
<li>Debiasing:</li>
<li><script type="math/tex; mode=display">\hat{m}_t = m_t/(1-\beta^t_1)</script></li>
<li><script type="math/tex; mode=display">\hat{v}_t = v_t/(1-\beta^t_2)</script><div style="width:40%; margin:0 auto"><img src="/2019/02/13/everyday-note/debiasing.png"></div></li>
<li>The final parameter update<ul>
<li><script type="math/tex; mode=display">w^{(t+1)} \leftarrow w^{(t)} - \eta \frac{\hat{m}_w}{\sqrt{\hat{v}_w}+\epsilon}</script></li>
<li>numerator means: for every parameter, take a in the direction of the gradient for that parameter</li>
<li>denominator means: normalize the step by its standard deviation</li>
</ul>
</li>
<li>The intuitive interpretation<ul>
<li>If the gradients are all pointing in different directions (high variance), we’ll take a small, cautious step.</li>
<li>If all the gradients are telling us to move in the same direction, the variance will be small, so we’ll take a bigger step in that direction.</li>
</ul>
</li>
</ul>
</li>
<li>LARS, <a href="https://arxiv.org/pdf/1708.03888.pdf" target="_blank" rel="noopener">Layerwise Adaptive Rate Scaling</a><ul>
<li>Trust ratio: the ratio between the nom of the layer weights and norm of gradients update.</li>
<li><script type="math/tex; mode=display">\lambda^l = \eta \times \frac{||w^l||}{||\nabla L(w^l)||}</script></li>
</ul>
</li>
<li>LAMB, Layer-wise Adaptive Moments optimizer for Batch training<ul>
<li>It makes a few small changes to LARS<ul>
<li><ol>
<li>If the numerator (r1 below) or denominator (r2 below) of the trust ratio is 0, then use 1 instead.</li>
</ol>
</li>
<li><ol>
<li>Fixing weight decay: in LARS, the denominator of the trust ratio is $|\nabla L|+\beta |W|$, whereas in LAMB it’s $|\nabla L + \beta W|$. this preserves more information.</li>
</ol>
</li>
<li><ol>
<li>Instead of using the SGD update rule, they use Adam update rule.</li>
</ol>
</li>
<li><ol>
<li>CLip the trust ratio at 10</li>
</ol>
</li>
</ul>
</li>
<li>So, the trust ratio in LAMB is</li>
<li><script type="math/tex; mode=display">r_1 = ||w_{t-1}^l||_2</script></li>
<li><script type="math/tex; mode=display">r_2 = ||\frac{\hat{m}_t^l}{\sqrt{\hat{v}_t^l+\epsilon}}+\lambda w_{t-1}^l||_2</script></li>
<li><script type="math/tex; mode=display">r = r_1/r_2</script></li>
<li><script type="math/tex; mode=display">\eta^l = r \times \eta</script></li>
<li><script type="math/tex; mode=display">w_t^l = w_{t-1}^l - \eta^l \times (\frac{\hat{m}_t^l}{\sqrt{\hat{v}_t^l+\epsilon}}+\lambda w_{t-1}^l)</script></li>
<li>$r_2$ it the norm of the Adam update rule with weight decay</li>
<li>$\eta^l$ is the layer-wise learning rate adjusted by the trust ratio</li>
<li>So, this method can be summarized as LARS applied to Adam</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-11-13"><a href="#2019-11-13" class="headerlink" title="2019-11-13"></a>2019-11-13</h3><ul>
<li>编程之美<ul>
<li>3.1 字符串移位包含问题<ul>
<li>解法一：循环查找，N很大时很慢</li>
<li>解法二：在字符串后面再复制一遍自身，然后直接查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-11-12"><a href="#2019-11-12" class="headerlink" title="2019-11-12"></a>2019-11-12</h3><ul>
<li>编程之美<ul>
<li>2.1 求二进制数中的1的个数<ul>
<li>解法一：循环用2除</li>
<li>解法二：循环位操作，向右移一位</li>
<li>解法三：只考虑1的位置，本身-1后和本身进行与操作，比如 $01000000 \&amp; (01000000-00000001) =01000000 \And 00111111 = 0$。 这样一直循环能把原二进制数中的1逐渐清空</li>
<li>解法四：如果位数少的话，用枚举</li>
</ul>
</li>
<li>2.3 寻找数组中出现次数最多的数字<ul>
<li>一般情况： 先排序后遍历查找</li>
<li>已知次数最多的数字占中数组的一半以上： 两个一对的删除掉不一样的两个数，最后剩下的就是占比一半以上的那个数字</li>
</ul>
</li>
<li>2.7 求最大公约数<ul>
<li>辗转相除法：$f(x, y) = f(y, y \mod x)$</li>
<li>辗转相减法：$f(x, y) = f(x-y, y)$ 如果输入$x&lt;y$, 就先替换位置。缺点是迭代次数较多，比如$f(1000000000,1)$情况下</li>
<li>位运算和减法：<ul>
<li>若$x, y$均为偶数，$f(x,y)=2\times f(x/2,y/2)=2\times f(x\gg 1,y\gg 1)$</li>
<li>若$x$为偶数，$y$为奇数，$f(x,y)=f(x/2,y)=f(x\gg 1,y)$</li>
<li>若$x$为奇数，$y$为偶数，$f(x,y)=f(x,y/2)=f(x,y\gg 1)$</li>
<li>若$x,y$均为奇数，$f(x,y)=f(x,x-y)$</li>
</ul>
</li>
</ul>
</li>
<li>2.8 找符合条件的整数（N*M结构每一位上都是0或者1）<ul>
<li>解法一：给定N，从小到大遍历M。搜索空间太大。</li>
<li>解法二：搜索N*M的符合要求的结果，即所有位置都是0或1的所有可能取值X，然后检查是否能被N整除，如果最终结构X有k为，则要搜索$2^k$次。</li>
<li>解法三：维护一个“余数信息数组”</li>
</ul>
</li>
<li>2.12 两数之和满足条件<ul>
<li>最巧妙做法：直接考虑两数之和的顺序。先对原数组进行排序，然后第0个元素和最后一个元素相加的结果就是所有可能的两数之和的中位数，接下来如果当前两数之和小于目标值则前面的下标加一，否则后面的下标加一，直到找到目标值。</li>
</ul>
</li>
<li>2.16 求数组中最长递增子序列<ul>
<li>解法一：根据无后效性，我只需要记住到当前位置为止的最长递增子序列，比如1, -1, 2, -3, 4, -5, 6为例，遍历到4后，我们不用关心之前的两个值具体是什么，因为这对后面找到6并没有什么直接的影响。要找到当前位置的最小值，只要遍历前面记录的最长递增子序列然后满足比当前值小就行。</li>
<li>解法二：在解法1的基础上再记录长度为$i$的递增子序列最大元素的最小值$MaxV[1]$，这样能减少内层遍历的次数。</li>
</ul>
</li>
<li>2.19 区间重合判断<ul>
<li>解法一：遍历无序的目标区间，对原始区间进行覆盖，看最后有没有剩余没覆盖到的区间</li>
<li>解法二：对无序的目标区间进行排序并合并连续的区间，然后用二分查找寻找原始区间有没有被其中一个不变连续的区间包含</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-11-11"><a href="#2019-11-11" class="headerlink" title="2019-11-11"></a>2019-11-11</h3><ul>
<li>leetcode #72: 编辑距离<ul>
<li>动态规划：对于 $word1$ 中的第$i$个字母和单词 $word2$ 中的第$j$个字母，如果他们俩一样，则：$D[i][j] =1 + min(D[i-1][j],  D[i][j-1], D[i-1][j-1] - 1)$， 如果他们俩不一样，则：$D[i][j] = 1 + min(D[i-1][j],  D[i][j-1], D[i-1][j-1])$, 其中 $D[i][j]$ 表示 $word1[:i]$ 和 $word2[:j]$ 之间的最短编辑距离。</li>
</ul>
</li>
</ul>
<h2 id="2019-10"><a href="#2019-10" class="headerlink" title="2019-10"></a>2019-10</h2><h3 id="2019-10-31"><a href="#2019-10-31" class="headerlink" title="2019-10-31"></a>2019-10-31</h3><ul>
<li>Medium: <a href="https://medium.com/@_init_/an-illustrated-explanation-of-using-skipgram-to-encode-the-structure-of-a-graph-deepwalk-6220e304d71b" target="_blank" rel="noopener">An Illustrated Explanation of Using SkipGram To Encode The Structure of A Graph (DeepWalk)</a><ul>
<li>Generating corpus by random walk </li>
</ul>
</li>
</ul>
<h3 id="2019-10-27"><a href="#2019-10-27" class="headerlink" title="2019-10-27"></a>2019-10-27</h3><ul>
<li>LeetCode 戳气球问题</li>
</ul>
<h3 id="2019-10-17"><a href="#2019-10-17" class="headerlink" title="2019-10-17"></a>2019-10-17</h3><blockquote>
<div title="无处不在的"> ubiquitous </div>
<div title="伪代码"> pseudo code </div>
<div title="备用的"> auxiliary </div>

</blockquote>
<h3 id="2019-10-10"><a href="#2019-10-10" class="headerlink" title="2019-10-10"></a>2019-10-10</h3><blockquote>
<div title="难处理地；难解决的"> intractable </div>
<div title="卖弄学问的"> pedantic </div>


</blockquote>
<ul>
<li>why maximum likelihood and not maximun probability<ul>
<li>$L(\mu, \sigma; data)=P(data;\mu, \sigma)$</li>
<li>Despite these two things being equal, the likelihood and the probability density are fundamentally asking different questions — one is asking about the data and the other is asking about the parameter values. </li>
</ul>
</li>
</ul>
<h2 id="2019-09"><a href="#2019-09" class="headerlink" title="2019-09"></a>2019-09</h2><h3 id="2019-09-29"><a href="#2019-09-29" class="headerlink" title="2019-09-29"></a>2019-09-29</h3><blockquote>
<ul>
<li><div title="不变性，恒定性"> invariance </div>

</li>
</ul>
</blockquote>
<h3 id="2019-09-27"><a href="#2019-09-27" class="headerlink" title="2019-09-27"></a>2019-09-27</h3><ul>
<li>用 weight normalization 或者 batch normallization 相当于给原始神经网络引入了一个不同的参数化过程。batch normalization就不是没有 re-parameterization 过程。</li>
</ul>
<h3 id="2019-09-26"><a href="#2019-09-26" class="headerlink" title="2019-09-26"></a>2019-09-26</h3><ul>
<li>paper: ALBERT<ul>
<li>三大改造：<ul>
<li>将词嵌入矩阵与后面的隐藏层脱离，这就可以使模型的隐藏层大小远远大于词嵌入向量的大小而不影响模型效果。</li>
<li>跨层参数共享，同时共享FFN层参数和Self-attention层的参数。结果是，每一层输入与输出嵌入矩阵间的L2距离与余弦相似度都变得平滑很多。</li>
<li>引入句间连贯性损失（SOP）。避免预测主题，只关注建模句子之间的连贯性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-09-25"><a href="#2019-09-25" class="headerlink" title="2019-09-25"></a>2019-09-25</h3><blockquote>
<ul>
<li><div title="使减小；使变少；变少">diminish</div></li>
<li><div title="正交的，直角的">orthogonal</div></li>
<li><div title="话虽如此"> That being said </div></li>
<li><div title="本质，精华"> essence </div></li>
<li><div title="初步的"> preliminary </div>


</li>
</ul>
</blockquote>
<ul>
<li><p>The difference between <code>xrange</code> and <code>range</code> in Python:</p>
<ul>
<li><code>range</code> returns a Python  <code>list</code> object</li>
<li><code>xrange</code> returns an <code>xrange</code> object witch is a <code>generators</code></li>
</ul>
</li>
<li><p>paper: Layer Normalization</p>
<ul>
<li>Problem of Batch Normalization:<ul>
<li>the effect is dependent on the mini-batch size</li>
<li>it is not obvious how to apply it to recurrent neural networks.</li>
</ul>
</li>
<li>Compare with Batch Normalization:<ul>
<li>Like batch normalization, we also give each neuron its own adaptive bias and gain which are applied after the normalization but before the non-linearity.</li>
<li>Unlike batch normalization, layer normalization performes exactly the same computation at training and test times. It is also straightforward to apply to recurrent neural networks by computing the normalization statistics separately at each time step.</li>
</ul>
</li>
<li>layer normalization is very effective at stabilizing the hidden state dynamics in recurrent networks. </li>
</ul>
</li>
</ul>
<h3 id="2019-09-24"><a href="#2019-09-24" class="headerlink" title="2019-09-24"></a>2019-09-24</h3><ul>
<li><p>排序算法的稳定性：</p>
<ul>
<li>稳定：冒泡、归并、插入、基数</li>
<li>不稳定：堆排序、快速、直接选择、希尔</li>
</ul>
</li>
<li><p>KNN 和 K-Means</p>
</li>
</ul>
<table width="80%" style="table-layout: fixed; margin:auto"> 
<tr>
<th>KNN</th>
<th>K-Means</th>
</tr>
<tr>
<td>1.分类算法 <br> 2.监督学习</td>
<td>1.聚类算法 <br> 2.非监督算法</td>
</tr>
<tr>
<td>没有明显的训练过程，只需要将所有数据载入到内存中，就可以对新输入的数据进行分类</td>
<td>有明显的训练过程，需要通过不停迭代找出最合适的K个平均值</td>
</tr>
<tr>
<td>K的意思是根据距离新数据最近的K个样本来对新数据进行分类</td>
<td>K的意思是假设所有的数据集中有K个种类，需要初始假设K个均值</td>
</tr>
<tr>
<td colspan="2">相似点：两者都用到了NN（Nearest Neighbor）思想，一般用KD树来实现</td>
</tr>
</table>

<h3 id="2019-09-23"><a href="#2019-09-23" class="headerlink" title="2019-09-23"></a>2019-09-23</h3><ul>
<li>论文笔记：核心思想、预备知识、模型、实验</li>
<li>transformer 中的 Add &amp; Norm 层：<ul>
<li>Add 层类似于残差连接，将自注意力层的输出与自身向量相加，让模型只需要在自注意力层学习增量信息，优点是可以学习到一些很细节的信息。</li>
<li>Norm 层用的是 layer normalization，与 batch normalization 相比优点是针对单样本，不依赖其它数据，可以避免 interval co-variate shift。</li>
<li>Feed-Forward Network：两层线性转换和一个激活层（RELU).</li>
</ul>
</li>
</ul>
<h3 id="2019-09-10"><a href="#2019-09-10" class="headerlink" title="2019-09-10"></a>2019-09-10</h3><ul>
<li>Kullback-Leibler Divergence &amp; Entropy<ul>
<li>entropy: it’s a way to quantify exactly how much information is in our data</li>
<li>KL divergence: a way to quantify how much information is lost from true distribution to parameterized approximation.</li>
<li>With KL divergence we can calculate exactly how much information is lost when we approximate one distribution with another.</li>
<li>Divergence not distance. The reason is that KL Divergence is not symmetric.</li>
</ul>
</li>
</ul>
<h3 id="2019-09-09"><a href="#2019-09-09" class="headerlink" title="2019-09-09"></a>2019-09-09</h3><ul>
<li>刘群：基于深度学习的自然语言处理：边界在哪里？<ul>
<li>自然语言处理的范式迁移：从规则，到统计，再到深度学习（我认为深度学习其实只是统计的延伸，严格意义上还是属于统计的范畴）<ul>
<li>人不可能将所有的规则都穷举出来，并且也写不出大量太细的规则。</li>
</ul>
</li>
<li>深度学习解决了自然语言处理哪些问题？<ul>
<li>词语形态问题（morphology）<ul>
<li>在中文中，它体现在词的切分上</li>
<li>在英语等大部分其他语言中则主要体现在形态分析上。</li>
<li>在统计机器翻译时代，有一个比较著名的方法叫做 Factored statistical machine translation （基于要素的翻译方法）：将一个词分成很多要素，然后分别翻译每个要素，最后汇总要素得到结果。</li>
<li>这个问题在神经网络框架下基本不成问题，因为现在机器翻译基本上可以不做分词，大部分中文机器翻译系统基本上基于汉子实现。</li>
</ul>
</li>
<li>句法结构问题<ul>
<li>在神经网络机器翻译框架下，神经网络可以很好的捕捉句子结构，无需进行句法分析，系统可以自动获得处理复杂结构句子的翻译的能力。</li>
</ul>
</li>
<li>多语言问题<ul>
<li>如果使用中间语言来作文多语言翻译系统的互通桥梁，需要开发的系统的数量随翻译语言的数量呈线性增长；否则，开发系统的数量随翻译语言的数量呈平方增长。</li>
<li>在基于统计方法的机器翻译时代，普遍采用Pivot方法，即在两个语言的互译中，先将所有语言翻译成英语，再翻译成另一种语言。以这种方法来实现多语言翻译。但是这样会导致错误传播和性能下降。</li>
</ul>
</li>
<li>联合训练问题<ul>
<li>在统计机器翻译时代，各个模块相互独立，导致错误传播的问题很严重。如果采用联合训练会导致模型的复杂度大大增加。</li>
<li>神经网络机器翻译框架下，端到端训练很容易实现。</li>
</ul>
</li>
</ul>
</li>
<li>还有哪些深度学习尚未解决的自然语言处理问题？<ul>
<li>资源短缺问题：商业系统的训练语料基本上都是数以千万计的，这在很多专业领域根本收集不到如此庞大的数据，尤其是一些小众语言。</li>
<li>可解释性和可信任问题：神经网络由于计算过程都是在高纬度空间中完成，缺乏可解释性，加之神经网络偶尔犯的一些错误会直接给人带来不信任感。</li>
<li>可控制性问题：当神经网络出现一些错误时我们几乎无法通过修改神经网络来修正这些错误。</li>
<li>超长文本问题：虽然最近提出的BERT、GPT等模型将单词可处理的句子长度扩展到了几百到上千字之多，但是长度超过千字的篇章翻译还是无法一次性完成，还有很多问题尚待解决。</li>
<li>缺乏常识问题：举个🌰。“Bank fishing is fishing from places where the land meets the water’s edge.” 谷歌翻译翻译成“银行捕鱼是从陆地与水边相遇的地方捕鱼的。”</li>
</ul>
</li>
<li>基于深度学习的自然语言处理，其边界在哪里？<ul>
<li>数据边界：数不够</li>
<li>语义边界：深度学习只能对字词符号之间的关系进行建模，并不能对所描述的问题语义或者输入的句子语义进行建模。</li>
<li>符号边界：再好的神经网络也只是在符号之间寻找规律，不能准确的定义或者描述任何特定的表达。</li>
<li>因果边界：通过观察数据能得出的结论永远只有关联性而不可能得出因果性。因果性必须有完备的理论和推理支持。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2019-08"><a href="#2019-08" class="headerlink" title="2019-08"></a>2019-08</h2><h3 id="2019-08-06"><a href="#2019-08-06" class="headerlink" title="2019-08-06"></a>2019-08-06</h3><ul>
<li>Tensorflow<ul>
<li>tf.expand_dims(input, axis)</li>
<li>tf.concat(values, axis)</li>
<li>tf.nn.bidirectional_dynamic_rnn(cell_fw, cell_bw, inputs)</li>
</ul>
</li>
</ul>
<h3 id="2019-08-02"><a href="#2019-08-02" class="headerlink" title="2019-08-02"></a>2019-08-02</h3><blockquote>
<ul>
<li><div title="陡峭的；完全的；垂直的">sheer</div></li>
<li><div title="观点；态度；意见">sentiment</div></li>
<li><div title="粒度">granularity</div></li>
<li><div title=" 不同种类的，多种多样的；混杂的">miscellaneours</div></li>
<li><div title="轶事的；趣闻的">anecdotal</div></li>
<li><div title="气氛；环境">ambience</div></li>
<li><div title="均匀的；平等的">evenly</div>


</li>
</ul>
</blockquote>
<ul>
<li><a href="https://medium.com/dair-ai/adapters-a-compact-and-extensible-transfer-learning-method-for-nlp-6d18c2399f62" target="_blank" rel="noopener">Adapters: A Compact and Extensible Transfer Learning Method for NLP</a><ul>
<li>在 transformer fine-tuning 的时候插入adapter 模块进行微调，原参数不参加训练，只训练adapter和最上层。</li>
</ul>
</li>
</ul>
<h2 id="2019-07"><a href="#2019-07" class="headerlink" title="2019-07"></a>2019-07</h2><h3 id="2019-07-30"><a href="#2019-07-30" class="headerlink" title="2019-07-30"></a>2019-07-30</h3><ul>
<li>哪些参数对于训练BERT模型至关重要（RoBERTa）：<ul>
<li>static masking VS. dynamic masking:<ul>
<li>static masking: 在数据预处理的时候 mask 一次，每次 epoch 中训练实例使用相同的 mask</li>
<li>dynamic masking： 避免让每次 epock 中的训练数据使用相同的 mask，具体方法是：如果一共训练40个epoch，我们就每训练4个 epoch 就重新进行 masking，这样重复10次，意味着每个训练序列都使用相同的 mask 四次。</li>
<li>动态 masking 的效果比静态的好一丢丢。</li>
</ul>
</li>
<li>模型输入格式和下一局预测：<ul>
<li>这里我没有看明白新智元的论文翻译，得去看一下原文。大致意思应该是他们采用没有NSP的完整句子。</li>
</ul>
</li>
<li>扩大 mini-batches, 并提高学习率</li>
</ul>
</li>
</ul>
<h3 id="2019-07-28"><a href="#2019-07-28" class="headerlink" title="2019-07-28"></a>2019-07-28</h3><blockquote>
<ul>
<li><div title="虚构的事/物"> figment </div>

</li>
</ul>
</blockquote>
<ul>
<li>macbook 突然没有声音解决方法： sudo killall coreaudiod 重置音频核心</li>
</ul>
<h3 id="2019-07-24"><a href="#2019-07-24" class="headerlink" title="2019-07-24"></a>2019-07-24</h3><ul>
<li>mac 复制文件地址： <code>option</code>+<code>commend</code>+<code>C</code></li>
<li>markdown文档中加 <code>&amp;nbsp;</code> 可以加空行</li>
</ul>
<h3 id="2019-07-18"><a href="#2019-07-18" class="headerlink" title="2019-07-18"></a>2019-07-18</h3><blockquote>
<ul>
<li><div title="推测；猜想"> conjecture </div>


</li>
</ul>
</blockquote>
<ul>
<li>AutoGraph: 可以将eager execution执行的tensorflow代码以计算图的方式执行，提高执行效率。<ul>
<li>autograph通过<code>contrib.autograph</code>获取</li>
<li>常用方法：<ul>
<li>修饰: <code>@autograph.convert(optional_features=...)</code></li>
<li>autograph.to_code()</li>
<li>autograph.to_graph()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-07-12"><a href="#2019-07-12" class="headerlink" title="2019-07-12"></a>2019-07-12</h3><blockquote>
<ul>
<li><div title="人造的"> synthetic </div></li>
<li><div title="根本地;彻底地;完全地"> redically </div>


</li>
</ul>
</blockquote>
<h3 id="2019-07-07"><a href="#2019-07-07" class="headerlink" title="2019-07-07"></a>2019-07-07</h3><ul>
<li><p>Linux 换源：</p>
<ul>
<li>apt: /etc/apt/sources.list</li>
<li>pip: ~/.pip/pip.conf</li>
<li>conda: ~/.condarc</li>
</ul>
</li>
<li><p>ssh 服务：</p>
<ul>
<li>开启/关闭开机自启：systemctl enable ssh</li>
<li>单次启动/关闭：systemctl start ssh</li>
</ul>
</li>
</ul>
<h3 id="2019-07-05"><a href="#2019-07-05" class="headerlink" title="2019-07-05"></a>2019-07-05</h3><blockquote>
<ul>
<li><div title="忽视；忽略">neglect</div>

</li>
</ul>
</blockquote>
<h3 id="2019-07-04"><a href="#2019-07-04" class="headerlink" title="2019-07-04"></a>2019-07-04</h3><ul>
<li>Batch Normalization<ul>
<li>一般归一化的是激活函数之前的$z^k$，也有researcher觉得应该归一化激活后的$a^k$</li>
</ul>
</li>
</ul>
<ul>
<li>Paper: Batch Normalization<ul>
<li>Fixing the distribution of the layer inputs $x$ as the training progresses to accelerate the training process.</li>
<li>It has been long known (LeCun’s Efficient BackProp) that the network training converges faster if its inputs are whitened, which means linearly transformed to have zero means and unit variance.</li>
<li>A potential problem is that the gradient descent optimization does not take into account the fact that the normalization takes place. Solution: ensure that, for any parameter values, the network always produces activations with the desired distribution.</li>
<li>The Jacobians</li>
</ul>
</li>
</ul>
<h3 id="2019-07-03"><a href="#2019-07-03" class="headerlink" title="2019-07-03"></a>2019-07-03</h3><blockquote>
<ul>
<li><div title="漂白"> whiten </div> </li>
<li><div title="间隔；幕间休息；间距"> interval </div></li>
<li><div title="散布,散置"> intersperse </div>

</li>
</ul>
</blockquote>
<ul>
<li>deeplearning.ai<ul>
<li>bias VS. variance:<ul>
<li>high bias: underfitting</li>
<li>high variance: overfitting</li>
<li>otherwise: good classifier</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-07-02"><a href="#2019-07-02" class="headerlink" title="2019-07-02"></a>2019-07-02</h3><blockquote>
<ul>
<li><div title="臭名昭著的；声名狼藉的"> notorious </div></li>
<li><div title="放大；扩大"> amplify </div></li>
<li><div title="补偿；报酬"> compensate </div></li>
<li>convergence VS. divergence</li>
<li><div title="坚固的；大量的；重大的；实质的"> substantial </div>


</li>
</ul>
</blockquote>
<ul>
<li>Paper: Batch Normalization<ul>
<li>Internal covariate shift: the distribution of each layer’s inputs changes during training, as the parameters of the previous layers change.</li>
<li>It allows us to use much higher learning rates and be less careful about initialization.</li>
<li>It also acts as a regularization, in some cases eliminating the need for Dropout. </li>
<li>Stochastic gradient descent (SGD)</li>
<li>Fixed distribution of inputs to a sub-network would have positive consequences for the layers outside the sub-network.</li>
<li>The saturated regime of the nonlinearity. Could be addressed by using Rectified Linear Units, $ReLU(x)=max(x,0)$, careful initialization, small learning rates.</li>
</ul>
</li>
</ul>
<h2 id="2019-06"><a href="#2019-06" class="headerlink" title="2019-06"></a>2019-06</h2><h3 id="2019-06-28"><a href="#2019-06-28" class="headerlink" title="2019-06-28"></a>2019-06-28</h3><ul>
<li>Paper: Advances in Pre-Training Distributed Word Representations:<ul>
<li>standard cbow model<ul>
<li>the objective of it is to maximize the log-likelihood of the probability of the words given their surrounding:<script type="math/tex; mode=display">\sum^{T}_{t=1}\log p(w_t|C_t)</script></li>
<li>scoring function (simply getting average):<script type="math/tex; mode=display">s(w,C)=\frac{1}{|C|}\sum_{w^\prime \in C}u^T_{w^\prime}v_w</script></li>
<li>word subsampling:<script type="math/tex; mode=display">p_{disc}(w) = 1 - \sqrt{\frac{t}{f_w}}</script></li>
</ul>
</li>
<li>position-dependent weighting<ul>
<li>reweight the context vectors</li>
<li>each position $p$ in a context window is associated with a vector $d_p$, which is learnt from training phase.<script type="math/tex; mode=display">v_C=\sum_{p\in P}d_p</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-06-27"><a href="#2019-06-27" class="headerlink" title="2019-06-27"></a>2019-06-27</h3><blockquote>
<ul>
<li><div title="未察觉...；无视...">be oblivious to</div></li>
<li><div title="混乱；使凌乱">clutter</div></li>
<li><div title="切线；切线的；离题的">tangent</div></li>
<li><div title="...的关键；难题">the crux of</div>



</li>
</ul>
</blockquote>
<h3 id="2019-06-24"><a href="#2019-06-24" class="headerlink" title="2019-06-24"></a>2019-06-24</h3><ul>
<li>hexo next 主题的图片边框： themes/next/source/css/_common/components/post/post-expand.styl。 部署前不要忘记hexo clean。</li>
<li>word frequency distribution, Zipf distribution, which implies that most of the words belongs to small subset of the entire vovabulary <a href="https://ieeexplore.ieee.org/abstract/document/165464" target="_blank" rel="noopener">(Li, 1992)</a>.</li>
</ul>
<h3 id="2019-06-18"><a href="#2019-06-18" class="headerlink" title="2019-06-18"></a>2019-06-18</h3><blockquote>
<ul>
<li><div title="复数；复数的"> plural </div></li>
<li><div title="杂货店"> grocery </div></li>
<li><div title="选民；构成部分"> constituent </div></li>
<li><div title="微妙的；细微的"> subtle </div></li>
<li><div title="离散的"> diffuse </div></li>
<li><div title="减轻；救济；安慰"> relief </div></li>
<li><div title="激烈的；猛烈的"> drastic </div>

</li>
</ul>
</blockquote>
<ul>
<li><a href="https://colah.github.io/posts/2015-09-Visual-Information/" target="_blank" rel="noopener">Information Theory</a><ul>
<li>entropy = optimal average length in coding problem</li>
<li>prefix codes - prefix property: no codeword should be the prefix of another codeword</li>
<li>short codewords reduce the average message length but are expensive, while long codewords increase the average message length but are cheep. <img src="/2019/02/13/everyday-note/code-cost-longshort.png"></li>
<li><img src="/2019/02/13/everyday-note/calculating-entropy.JPG"></li>
<li>The more concentrated the probability, the more people can craft a clever code with short average messages. The more diffuse the probability, the longer people’s messages have to be.<ul>
<li>If there’s two things that could happen with 50% probability, people only need to send 1 bit. </li>
<li>If there’s 64 different things that could happen with equal probability, they would have to send 6 bits. </li>
</ul>
</li>
<li>entropy VS. cross entropy:<ul>
<li>cross entropy - the average length of communicating an event from one distribution with the optimal code for another distribution: <img src="/2019/02/13/everyday-note/cross-entropy.JPG"></li>
<li>cross-entropy isn’t symmetric. The more different the distributions $p$ and $q$ are, the more the cross-entropy of $p/q$ with respect to $q/p$ will be bigger than the entropy of $p/q$: <img src="/2019/02/13/everyday-note/cross-entropy-unsymmetrical.JPG"></li>
<li>This kind of difference is called Kullback-Leibler (KL) divergence: <script type="math/tex; mode=display">D_q(p)=H_q(p) - H(p)</script>KL divergence like a distance between two distributions. It measures how different they are</li>
</ul>
</li>
<li>conditional entropy: <script type="math/tex; mode=display">\begin{split} H(X|Y) &= \sum_{y}p(y)\sum_{x}p(x|y)log_2(\frac{1}{p(x|y)})\\ &=\sum_{x,y}p(x|y)log_2(\frac{1}{p(x|y)})\end{split}</script></li>
</ul>
</li>
</ul>
<h3 id="2019-06-13"><a href="#2019-06-13" class="headerlink" title="2019-06-13"></a>2019-06-13</h3><blockquote>
<ul>
<li>cumbersome</li>
<li>polysemy</li>
<li>as it were</li>
</ul>
</blockquote>
<ul>
<li>two properties of sigmoid function:<script type="math/tex; mode=display">\sigma(-u) = 1-\sigma(u)</script><script type="math/tex; mode=display">\frac{d\sigma(u)}{du} = \sigma(u)\sigma(-u)</script></li>
</ul>
<h3 id="2019-06-11"><a href="#2019-06-11" class="headerlink" title="2019-06-11"></a>2019-06-11</h3><blockquote>
<ul>
<li>derivation</li>
<li>hierarchical</li>
<li>posterior</li>
</ul>
</blockquote>
<ul>
<li>python 中的 StopIteration 异常。</li>
</ul>
<h3 id="2019-06-10"><a href="#2019-06-10" class="headerlink" title="2019-06-10"></a>2019-06-10</h3><blockquote>
<ul>
<li>abound</li>
</ul>
</blockquote>
<ul>
<li>NLP tag:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Scheme</th>
<th style="text-align:center">Begin</th>
<th style="text-align:center">Inside</th>
<th style="text-align:center">End</th>
<th style="text-align:center">Single</th>
<th style="text-align:center">Other</th>
</tr>
</thead>
<tbody>
<tr>
<td>IOB</td>
<td style="text-align:center">B-X</td>
<td style="text-align:center">I-X</td>
<td style="text-align:center">I-X</td>
<td style="text-align:center">B-X</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td>IOE</td>
<td style="text-align:center">I-X</td>
<td style="text-align:center">I-X</td>
<td style="text-align:center">E-X</td>
<td style="text-align:center">E-X</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td>IOBES</td>
<td style="text-align:center">B-X</td>
<td style="text-align:center">I-X</td>
<td style="text-align:center">E-X</td>
<td style="text-align:center">S-X</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Activation Funciton:<ul>
<li>can add non-linearity to the output, so it makes neural network solve non-linear problems</li>
<li>type:<ul>
<li>linear</li>
<li>sigmoid</li>
<li>tanh</li>
<li>Rectified Linear Unit (ReLU)</li>
<li>softmax</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-06-04"><a href="#2019-06-04" class="headerlink" title="2019-06-04"></a>2019-06-04</h3><blockquote>
<ul>
<li>derivatives</li>
<li>integrals</li>
<li>differential equations</li>
<li>pendulum</li>
</ul>
</blockquote>
<ul>
<li>3Blue1Brown: 微分方程概论-第一章<ul>
<li>Ordinary Differential Equation(ODE) VS. Partial Diffential Equation(PDE)<ul>
<li>PDE: think of them as involving a continum of values changing with time, like the temperature at every point of a solid body</li>
</ul>
</li>
<li>Second Order Differential Equation:<ul>
<li>whih means the highest derivative you find in this expression is a second derivative</li>
<li>higher-order differential equations include derivatives more than two</li>
</ul>
</li>
<li>phase space</li>
</ul>
</li>
</ul>
<h2 id="2019-05"><a href="#2019-05" class="headerlink" title="2019-05"></a>2019-05</h2><h3 id="2019-05-31"><a href="#2019-05-31" class="headerlink" title="2019-05-31"></a>2019-05-31</h3><ul>
<li>修改graph结构：<code>tf.import_graph_def(graph_def,name=&#39;&#39;, input_map={&#39;model_intent/embedding_lookup:0&#39;: char_embed})</code></li>
</ul>
<h3 id="2019-05-29"><a href="#2019-05-29" class="headerlink" title="2019-05-29"></a>2019-05-29</h3><ul>
<li>python 中 write 和 writeline 区别：write只能以字符串为参数，writeline可以传入字符列表。</li>
</ul>
<h3 id="2019-05-29-1"><a href="#2019-05-29-1" class="headerlink" title="2019-05-29"></a>2019-05-29</h3><blockquote>
<ul>
<li>enact</li>
<li>curb</li>
<li>proliferate</li>
</ul>
</blockquote>
<ul>
<li>最小二乘法：将需要预估的参数作为变量，对每个变量求偏导，求每个变量倒数为0的解: <script type="math/tex; mode=display">\hat{\beta}=(X^TX)^{-1}X^Ty</script></li>
</ul>
<h3 id="2019-05-21"><a href="#2019-05-21" class="headerlink" title="2019-05-21"></a>2019-05-21</h3><ul>
<li>在序列标准任务中，逐帧softmax和条件随机场（CRF）的根本不同：<strong>前者将序列标注看成是n个k分类问题，后者将序列标注看成是1个 $k^n$ 分类问题</strong>。</li>
</ul>
<h3 id="2019-05-15"><a href="#2019-05-15" class="headerlink" title="2019-05-15"></a>2019-05-15</h3><blockquote>
<p>生词：</p>
<ul>
<li>imaginary friend</li>
</ul>
</blockquote>
<ul>
<li>Information Theory:<ul>
<li>Simpson’s Paradox  <img src="/2019/02/13/everyday-note/simpson-separated-note.png"></li>
<li>code:<ul>
<li>prefix property: no codeword should be the prefix of another codeword</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-05-14"><a href="#2019-05-14" class="headerlink" title="2019-05-14"></a>2019-05-14</h3><blockquote>
<p>生词：</p>
<ul>
<li>toll</li>
<li>optic</li>
<li>retina</li>
<li>stave off</li>
<li>gadget</li>
<li>unerringly</li>
<li>I have <strong>misgiving</strong> about…</li>
<li>intimidate</li>
</ul>
</blockquote>
<h3 id="2019-05-09"><a href="#2019-05-09" class="headerlink" title="2019-05-09"></a>2019-05-09</h3><blockquote>
<p>生词：</p>
<ul>
<li>metabolism</li>
<li>keeps on ticking</li>
<li>glucose</li>
<li>rev up</li>
<li>molecular</li>
<li>carbs</li>
<li>exercise regimen</li>
<li>stunning feat of plasticity</li>
</ul>
</blockquote>
<ul>
<li>词袋模型 bag-of-word</li>
</ul>
<h3 id="2019-05-05"><a href="#2019-05-05" class="headerlink" title="2019-05-05"></a>2019-05-05</h3><ul>
<li>Transformer:<ul>
<li>encoder 最后一层的输出会在decoder每一层被用到。</li>
<li>multi-head attention 层是为了找出tokens之间的关系，之后的add是为了让它不要忘记自己。</li>
<li>the Dot-Product Attention for head $i$ : <script type="math/tex; mode=display">Attention(Q_i,K_i,V_i) = softmax(\frac{Q_iK_i^{T}}{\sqrt[]{d_k}})V_i</script><ul>
<li>其中：<ul>
<li>$Q_i = XW_i^Q$ ，维度为 $input\_length \times d_k$</li>
<li>$K_i = XW_i^K$ ，维度为 $input\_length \times d_k$</li>
<li>$V_i = XW_i^V$ ，维度为 $input\_length \times d_v$</li>
</ul>
</li>
<li>论文中（<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is all your need</a>）使用$d_k=d_v=\frac{emb\_dim}{h}$</li>
<li>不同 <em>head</em> 不共享$W_i^Q$，$W_i^K$和$W_i^V$，且都是随机初始化。</li>
<li>decoder block 里有两层multi-head attention加一层feed forward，第一层attention用来找出target sequence里的关系（需要用到mask，只允许看对应token的左边的token），第二层attention结合encoder的输出（E）和decoder上一个block的输出（D）,是为了用encoder的input sequence中各个token来表示target sequence中的各个token,相应的：<ul>
<li>$Q_i = DW_i^Q$ ，维度为 $target\_length \times d_k$</li>
<li>$K_i = EW_i^K$ ，维度为 $input\_length \times d_k$</li>
<li>$V_i = EW_i^K$ ，维度为 $input\_length \times d_v$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2019-04"><a href="#2019-04" class="headerlink" title="2019-04"></a>2019-04</h2><h3 id="2019-04-25"><a href="#2019-04-25" class="headerlink" title="2019-04-25"></a>2019-04-25</h3><blockquote>
<p>生词：</p>
<ul>
<li><strong>diverse</strong> application domains</li>
<li>propose a <strong>taxonomy</strong></li>
</ul>
</blockquote>
<h3 id="2019-04-19"><a href="#2019-04-19" class="headerlink" title="2019-04-19"></a>2019-04-19</h3><blockquote>
<p>生词：</p>
<ul>
<li><strong>granular</strong> cell</li>
<li><strong>scrutinize</strong> over the concept</li>
</ul>
</blockquote>
<ul>
<li>word2vector<ul>
<li>高频词汇采样</li>
<li>负采样: 每次只更新target词和随机几个（5-20）“negative word”对应的权重，减小计算量，加快训练过程。</li>
</ul>
</li>
</ul>
<h3 id="2019-04-17"><a href="#2019-04-17" class="headerlink" title="2019-04-17"></a>2019-04-17</h3><blockquote>
<p>生词：</p>
<ul>
<li>chronic</li>
<li>exceedingly</li>
<li>bound to be exceedingly limited</li>
</ul>
</blockquote>
<ul>
<li>三星手机添加notification提示音：<ul>
<li>在手机文件个目录里新建一个‘Media’文件夹</li>
<li>在‘Media’文件夹里新建‘Notifications’文件夹</li>
<li>在‘Notifications’里添加<code>.MP3</code>文件</li>
</ul>
</li>
</ul>
<h3 id="2019-04-15"><a href="#2019-04-15" class="headerlink" title="2019-04-15"></a>2019-04-15</h3><ul>
<li>Discriminative Model VS. Generative Model<ul>
<li>Discriminative: they model the decision boundary between the different classes, such as Logistic Regression which based on Maximum Likelihood.</li>
<li>Generative model: they model how the data was generated can be used to make classifications, such as Naive Bayes.</li>
</ul>
</li>
<li><a href="https://towardsdatascience.com/checklist-for-debugging-neural-networks-d8b2a9434f21?source=email-b01757374e14-1555187113798-digest.reader------1-58------------------811dbe59_37a4_4c19_9db6_ee6b790471a8-1&amp;sectionName=top" target="_blank" rel="noopener">Debugging Neural Networks</a><ol>
<li>Start simple:<ul>
<li>Building a simpler model first. Then gradually add model complexity.</li>
<li>Train your model on a single data point. Using 1 or 2 training data points to confirm whether model is able to overfit, which means it immediately overfit with a training accuracy of 100% and random guessing in validation phase.</li>
</ul>
</li>
<li>Confirm your loss:<ul>
<li>The loss is appropriate for the task(choosing cross-entropy loss or mean squared error?)</li>
<li>Your loss functions are being measured on the correct scale. It’s best to first check the data loss alone (so set regularization strength to zero).</li>
</ul>
</li>
<li>Check intermediate outputs and connections</li>
<li>Diagnose parameters<ul>
<li>Batch size: <ul>
<li>Small batch sizes will result in a learning process that converges quickly at the cost of noise in the training process and might lead to optimization difficulties.</li>
<li>Large-batch methods tend to converge to sharp minimizers of the training and testing functions-and as is well known, sharp minima lead to poorer generalization.</li>
</ul>
</li>
<li>Learning rate: Consider incorporating learning rate scheduling to decrease the learning rate as training progresses</li>
<li>Gradient clipping: Useful for addressing any exploding gradients.</li>
<li>Batch normalization: Fight the internal covariate shift problem.</li>
<li>Stochastic Gradient Descent (SGD): A recommended starting point is Adam or plain SGD with Nesterov momentum.</li>
<li>Regularization: </li>
<li>Dropout</li>
</ul>
</li>
<li>Track your work</li>
</ol>
</li>
</ul>
<h3 id="2019-04-11"><a href="#2019-04-11" class="headerlink" title="2019-04-11"></a>2019-04-11</h3><blockquote>
<p>生词：</p>
<ul>
<li>get accustomed to</li>
<li>take on</li>
<li>leverage</li>
<li>prominent</li>
<li>autonomy</li>
</ul>
</blockquote>
<h3 id="2019-04-09"><a href="#2019-04-09" class="headerlink" title="2019-04-09"></a>2019-04-09</h3><blockquote>
<p>生词：</p>
<ul>
<li>unary</li>
<li>sophisticated</li>
<li>prevalent</li>
<li>latent</li>
</ul>
</blockquote>
<ul>
<li>Transfer Learning:<ul>
<li>transfer learning is the process of trainibg a model on a large-scale dataset and then using that pretrained model to conduct learning for another downstream task.</li>
<li>recent work:<ul>
<li><a href="https://arxiv.org/abs/1801.06146" target="_blank" rel="noopener">ULMFit</a></li>
<li><a href="https://allennlp.org/elmo" target="_blank" rel="noopener">ELMo</a>: 2 layers of LSTM</li>
<li><a href="https://arxiv.org/abs/1806.05662" target="_blank" rel="noopener">GLoMo</a></li>
<li><a href="https://blog.openai.com/language-unsupervised/" target="_blank" rel="noopener">OpenAI transformer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-04-04"><a href="#2019-04-04" class="headerlink" title="2019-04-04"></a>2019-04-04</h3><blockquote>
<p>生词：</p>
<ul>
<li>cope with</li>
<li>be composed of</li>
<li>sanitary</li>
<li>sock</li>
<li>disinfectant</li>
<li>armrest</li>
<li>fungal</li>
</ul>
</blockquote>
<h3 id="2019-04-03"><a href="#2019-04-03" class="headerlink" title="2019-04-03"></a>2019-04-03</h3><blockquote>
<p>生词：</p>
<ul>
<li>have a <strong>self-consciousness</strong></li>
<li>bungling goon</li>
<li>play is <strong>innate</strong></li>
<li>for the sake of</li>
<li><strong>befuddled</strong> aunt/uncle/parent</li>
<li><strong>enamored</strong> with face</li>
<li>recess</li>
<li>paramount</li>
<li>wane</li>
<li>sophisticate</li>
</ul>
</blockquote>
<ul>
<li>How to interact with children:<ul>
<li>Ages 0-1:<ul>
<li>attraction to faces (expressions) only grows from there</li>
<li>speak as much as possible using baby talk with infant</li>
</ul>
</li>
<li>Ages 1-3:<ul>
<li>wait for an invitation into the child’s world. Follow their verbal and nonverbal cues.</li>
</ul>
</li>
<li>Ages 3-5:<ul>
<li>don’t push child to learning school readiness and other skills.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-04-02"><a href="#2019-04-02" class="headerlink" title="2019-04-02"></a>2019-04-02</h3><blockquote>
<p>生词：</p>
<ul>
<li>obsessive-compulsive disorder(OCD)</li>
</ul>
</blockquote>
<h2 id="2019-03"><a href="#2019-03" class="headerlink" title="2019-03"></a>2019-03</h2><h3 id="2019-03-30"><a href="#2019-03-30" class="headerlink" title="2019-03-30"></a>2019-03-30</h3><!-- more -->
<blockquote>
<p>生词:</p>
<ul>
<li>dodge</li>
<li>legitimate</li>
<li>folk</li>
<li>profitable</li>
</ul>
</blockquote>
<h3 id="2019-03-28"><a href="#2019-03-28" class="headerlink" title="2019-03-28"></a>2019-03-28</h3><blockquote>
<p>生词：</p>
<ul>
<li>grasp</li>
<li>slang</li>
</ul>
</blockquote>
<ul>
<li><a href="https://www.tensorflow.org/tutorials/representation/word2vec" target="_blank" rel="noopener">Word2vec</a>：<ul>
<li>有两种类型<ul>
<li>连续词袋模型（CBOW）：根据上下文预测目标字词</li>
<li>Skip-Gram：根据从目标字词中预测上下文字词</li>
</ul>
</li>
<li>噪声对比估算（NCE）损失是基于逻辑回归模型进行定义的</li>
</ul>
</li>
<li><a href="https://nlp.stanford.edu/projects/glove/" target="_blank" rel="noopener">GloVe</a>:<ul>
<li>先从文本中处理得到一个word-word co-occurrence矩阵 <img src="/2019/02/13/everyday-note/word-word-co-occurrence-matrix.png" title="word-word co-occurrence矩阵的一个小栗子"></li>
<li>训练过程是让词向量的点乘结果尽可能等于相应两个词一起出现的概率的对数。</li>
</ul>
</li>
</ul>
<h3 id="2019-03-26"><a href="#2019-03-26" class="headerlink" title="2019-03-26"></a>2019-03-26</h3><blockquote>
<p>生词：</p>
<ul>
<li>meteor</li>
<li>splash</li>
<li>bruise</li>
<li>shatter</li>
<li>flock </li>
<li>patio</li>
<li>bureaucratic</li>
<li>unlikely</li>
<li>trickle</li>
<li>deficiency</li>
<li>patriotic</li>
</ul>
</blockquote>
<ul>
<li>vim:<ul>
<li>v: 可视模式</li>
<li>w/b：前一个单词/后一个单词</li>
<li>^：本行第一个不是blank字符的位置</li>
<li>0：本行第一个位置</li>
<li>$：本行行尾</li>
<li>g_：本行最后一个不是blank字符的位置</li>
<li>p：黏贴</li>
<li>u：undo</li>
<li>CTRL-r：redo</li>
<li>d: 删除并复制</li>
<li>y：直接复制</li>
</ul>
</li>
</ul>
<h3 id="2019-03-21"><a href="#2019-03-21" class="headerlink" title="2019-03-21"></a>2019-03-21</h3><ul>
<li>从远程Git库中下在分支到本地：<ul>
<li><code>git pull origin branch_name:local_name</code> ：获取远程库中的branch_name分支与本地的local_name分支进行merge，如果要与本地当前分支进行merge可以不写冒号和冒号后面内容，如果本地所在的当前分支（dev）与对应远程分支（origin/dev）已建立联系，只需 <code>git pull origin</code></li>
<li><code>git checkout -b local_name origin/branch_name</code>: 自动创建一个新的本地分支（local_name），并与指定远程分支关联起来。</li>
</ul>
</li>
</ul>
<h3 id="2019-03-19"><a href="#2019-03-19" class="headerlink" title="2019-03-19"></a>2019-03-19</h3><ul>
<li>支持向量机 (Support Vector Machine)：<ul>
<li>支持向量 (support vectors):<ul>
<li>support vectores are the samples that are most difficult to classify</li>
<li>they directly affect the process to find the optimum location of the decision boundaries.</li>
</ul>
</li>
<li>constrained optimization - Lagrange Multipliers<ul>
<li>obtaining extrema of function $f(x,y)$ under the constraint $g(x,y) = A$ -&gt; $f^\prime(x,y) = \lambda g^\prime(x,y)$:</li>
</ul>
</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">\begin{split}
f^\prime (x,y) &= [f(x,y) + \lambda(A-g(x,y))]^\prime\\
 &=f^\prime(x,y) - \lambda g^\prime(x,y) = 0
\end{split} \tag{19.03.19.1}</script><ul>
<li>Math in Markdown<ul>
<li>one expression in multi-lines : \begin{split} align by ‘&amp;’ before ‘=’</li>
<li>multi-expressions in multi-lines : \begin{eqnarray*} align by ‘&amp;…&amp;’ wrap ‘=’</li>
</ul>
</li>
</ul>
<h3 id="2019-03-06"><a href="#2019-03-06" class="headerlink" title="2019-03-06"></a>2019-03-06</h3><blockquote>
<p>生词：</p>
<ul>
<li>treadmill</li>
<li>stationary</li>
<li>rack up</li>
<li>bold</li>
<li>obligation</li>
</ul>
</blockquote>
<h3 id="2019-03-05"><a href="#2019-03-05" class="headerlink" title="2019-03-05"></a>2019-03-05</h3><ul>
<li>Conda 操作：<ul>
<li>信息： <code>conda info</code></li>
<li>更新自己： <code>conda update conda</code></li>
<li>安装/更新 包：<code>conda install/update [package]</code></li>
<li>创建一个新python环境：<code>conda create --name mingzi python=3.6</code></li>
<li>激活一个python环境：<code>activate mingzi</code> (Win)/<code>source activate mingzi</code> (Linux/mac)</li>
<li>取消激活当前环境：<code>deactivate</code> (Win)/ <code>source deactivate</code> (Linux/mac)</li>
<li>环境列表：<code>conda env list</code></li>
</ul>
</li>
</ul>
<h3 id="2019-03-04"><a href="#2019-03-04" class="headerlink" title="2019-03-04"></a>2019-03-04</h3><ul>
<li>Vim 操作：<ul>
<li>dd -&gt; 删除当前行，并将这行保存到剪切板里</li>
<li>p -&gt; 粘贴剪切板里的内容</li>
<li>h，j，k，l -&gt; 移动光标（方向键也可以）</li>
<li>：help \<command> -&gt;  显示相关命令的帮助</li>
<li>u -&gt; 撤销（undo）</li>
</ul>
</li>
</ul>
<h2 id="2019-02"><a href="#2019-02" class="headerlink" title="2019-02"></a>2019-02</h2><h3 id="2019-02-28"><a href="#2019-02-28" class="headerlink" title="2019-02-28"></a>2019-02-28</h3><blockquote>
<p>生词：</p>
<ul>
<li>arithmetic</li>
</ul>
</blockquote>
<ul>
<li>Attention mechanism:<ul>
<li>attention 计算时(softmax之前)，每个待加权部分（$y_i$）的权重只跟上下文（context）$C$ 有关，与别的部分（$y_j, j \neq i$）无关。如下图： <img src="/2019/02/13/everyday-note/attention.JPG"></li>
<li>Soft Attention vs. Hard Attention<ul>
<li>soft attention: 结果为各个待加权部分的加权和</li>
<li>hard attention：结果为根据相应概率随机选取的一个待加权部分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2019-02-19"><a href="#2019-02-19" class="headerlink" title="2019-02-19"></a>2019-02-19</h3><blockquote>
<p>生词：</p>
<ul>
<li>tickle</li>
<li>sibling</li>
<li>stroke a cat</li>
<li>discrepancy</li>
<li>procrastinate</li>
<li>prone</li>
</ul>
</blockquote>
<ul>
<li>scp命令：<code>scp test.txt  account@ip:/home/xxx/test.txt</code> </li>
</ul>
<h3 id="2019-02-17"><a href="#2019-02-17" class="headerlink" title="2019-02-17"></a>2019-02-17</h3><blockquote>
<p>生词：</p>
<ul>
<li>anecdote</li>
<li>instill</li>
<li>ostracism/banishment</li>
<li>squeak</li>
</ul>
</blockquote>
<ul>
<li>向量叉乘（cross product）， 如果逆时针方向相乘则结果为正，反之结果为负。叉乘的结果（三维空间）为一个向量，这个向量的大小是两个相乘的向量所构成的平行四边形的面积，方向与该平行四边形垂直。求解两个向量的叉乘可以用求解对应行列式的方法（加上一个向量 ($\hat{i},\hat{j}, \hat{k}$)）</li>
<li>线性的严格定义（Formal definition of linearity）:<ul>
<li>可加性： $L(\vec{v}+\vec{w})=L(\vec{v})+L(\vec{w})$</li>
<li>成比性：$L(c\vec{v})=cL(\vec{v})$</li>
</ul>
</li>
<li>因此，函数只要满足上面的规定也是线性的。</li>
<li>The learning your do learning forward can be substantially more efficient if you have all the right intuitions in places.</li>
</ul>
<h3 id="2019-02-15"><a href="#2019-02-15" class="headerlink" title="2019-02-15"></a>2019-02-15</h3><blockquote>
<p>生词：</p>
<ul>
<li>perusal</li>
<li>connotation</li>
<li>fumble</li>
<li>clumsily</li>
<li>intercept</li>
<li>distort</li>
<li>perception</li>
<li>clutter</li>
<li>duality</li>
</ul>
</blockquote>
<ul>
<li><code>GraphDef</code> 是TensorFlow用来保存/加载<code>Graph</code>时的中间对象。保存时，可以通过<code>Graph.as_graph_def()</code>或者<code>Session.graph_def</code>获取到<code>GraphDef</code>对象用于序列化保存到文件；加载时，也需要先用<code>tf.GraphDef()</code>获取一个空<code>GraphDef</code>对象然后用 <strong>.pb</strong> 文件中的数据来填充（<code>graph_def.ParseFromString(f.read())</code>）,最后通过<code>tf.import_graph_def(graph_def, name=&#39;prefix&#39;)</code>的形式加载到指定的Graph中。</li>
<li>对偶性： 两种数学事物之间自然而又出乎意料的对应关系</li>
</ul>
<h3 id="2019-02-14"><a href="#2019-02-14" class="headerlink" title="2019-02-14"></a>2019-02-14</h3><blockquote>
<p>生词：</p>
<ul>
<li>spouse</li>
<li>tepastry</li>
<li>gargantuan</li>
</ul>
</blockquote>
<ul>
<li><p>用 <code>tf.train.Saver()</code> 保存/载入模型：</p>
<ul>
<li><p><strong>.data</strong> 文件保存权重（weights）；<strong>.meta</strong> 文件保存计算图的各种元数据（metadata）比如学习率和优化器； <strong>.index</strong> 文件保存键-值对，用来根据模型中的tensor name在 .data 文件中找到相应的data。</p>
<ul>
<li><strong>载入图结构和元数据</strong> 用 <code>tf.train.import_meta_graph(&#39;models/model.ckpt-1000.meta&#39;)</code>, 该方法自动将 “models/model.ckpt-1000.meta” 文件中保存的图加载到默认图（default_graph）中并返回一个 <code>Saver</code>。</li>
<li><strong>回复/载入权重（weights）</strong> 的过程跟载入图结构和元数据不同的是它必须在要给 <code>Session</code> 中执行，可以把它理解为权重的初始化类似的过程，如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment">#用载入权重的方式来初始化权重，就不需要tf.global_variables_initializer()过程了</span></span><br><span class="line">    saver.restore(sess, <span class="string">'models/model.ckpt.data-1000-00000-of-00001'</span>)</span><br><span class="line">    print(sess.run(global_step_tensor))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可以声明多个 <code>Saver</code> 来保存所有或特定变量（<code>Variables</code>）并用字典({name:Var})的形式给变量指定名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1 = tf.Variable(<span class="number">1.</span>, name=<span class="string">"v1"</span>)</span><br><span class="line">all_saver = tf.train.Saver()</span><br><span class="line">v1_saver = tf.train.Saver(&#123;<span class="string">"V1"</span>:v1&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个 <code>Saver</code> 只能保存当前 <code>Session</code> 对应 <code>Graph</code> 中的变量,所以程序中有多个 <code>Graph</code> 时要注意 <code>Saver</code> 的使用，下面这样使用 <code>Saver</code> 就会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">g = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> g.as_default():</span><br><span class="line">    v1 = tf.Variable(<span class="number">5.</span>, dtype=tf.float32)</span><br><span class="line">print(v1.graph == g) <span class="comment"># 输出True</span></span><br><span class="line">print(v1.graph == tf.get_default_graph()) <span class="comment"># 输出False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个Saver如果在绑定默认default_graph的Session中执行会报错，因为v1是在 g 中的变量而不是default_graph中</span></span><br><span class="line">saver = tf.train.Saver([v1])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line"></span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    saver.save(sess, <span class="string">'./test'</span>) <span class="comment">#执行这句代码时会报错</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>用 <code>tf.saved_model.simple_save</code> 保存模型：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">simple_save(session,</span><br><span class="line">            export_dir,</span><br><span class="line">            inputs=&#123;<span class="string">"x"</span>: x, <span class="string">"y"</span>: y&#125;),</span><br><span class="line">            outputs=&#123;<span class="string">"z"</span>: z&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>.pb</strong> 文件保存图结构和元数据； <strong>variables</strong> 文件夹内保存当前的权重。</li>
<li>加载saved_model：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export_dir = ...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">with</span> tf.Session(graph=tf.Graph()) <span class="keyword">as</span> sess:</span><br><span class="line">    tf.saved_model.loader.load(sess, [tag_constants.TRAINING], export_dir)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>把模型的所有信息（包括图数据和权重信息）全部保存到一个 .pb 文件中：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> graph_util</span><br><span class="line">output_graph_def = graph_util.convert_variables_to_constants(session, </span><br><span class="line">                                                             session.graph_def,</span><br><span class="line">                                                             output_node_names=[</span><br><span class="line">                                                                         <span class="string">'model_intent/intent_scores'</span>])</span><br><span class="line"><span class="keyword">with</span> tf.gfile.FastGFile(<span class="string">'models/intent_model.pb'</span>, mode=<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(output_graph_def.SerializeToString())</span><br></pre></td></tr></table></figure>
<p>  加载保存的 .pb 文件：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_graph</span><span class="params">(frozen_graph_filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.gfile.GFile(frozen_graph_filename, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        graph_def = tf.GraphDef()              <span class="comment"># 创建一个空的graph_def</span></span><br><span class="line">        graph_def.ParseFromString(f.read())    <span class="comment"># 用 .pb 文件中保存的对象填充该graph_def</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Graph().as_default() <span class="keyword">as</span> graph:</span><br><span class="line">        <span class="comment"># 下面的name参数的值会作为graph中所有op的前缀</span></span><br><span class="line">        tf.import_graph_def(graph_def, name=<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="keyword">return</span> graph</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2019-02-13"><a href="#2019-02-13" class="headerlink" title="2019-02-13"></a>2019-02-13</h3><ul>
<li>线性变换（Linear transformation）就是输入一个向量然后输出另一个向量。这里的transformation(变换)和function（函数）同义，之所以用transformation是因为线性代数里面的线性变换是可以在坐标系中（低维）可视化表现出来的。前面的形容词Linear的意思是：整个坐标系变换之后直线依旧是直线，原点保持固定。下面两个变换都不是线性变换(灰线表示原坐标系)。</li>
</ul>
<img src="/2019/02/13/everyday-note/unlinear.JPG"> <img src="/2019/02/13/everyday-note/unlinear1.JPG">
<ul>
<li>矩阵乘法相当于两个线性变换的复合。类似：<img src="/2019/02/13/everyday-note/Composition.JPG"> 线性变换的行列式 可以理解为线性变换后原单位面积被拉伸/压缩的倍数。 用这个概念很好理解：<script type="math/tex; mode=display">det(M_1M_2)=det(M_1)det(M_2)</script><strong>矩阵的逆</strong> 在transformation上的变现形式就是逆变换（顺时针旋转90度对应的矩阵的逆就是逆时针旋转90度对应的矩阵），因此矩阵A乘以矩阵A的逆表示变换之后又逆变换，相当于什么都没做.</li>
<li>矩阵（或者说线性变换）的 秩（rank）可以理解为线性变换结束后整个坐标系的维度（维度是否被压缩，或者保持原维度）。更加严谨的定义是矩阵列空间的维度（换句话说就是所有列向量可以在几维空间里表示）。所以顾名思义，满秩，表示任何两个列向量都不线性相关即秩数等于列向量的个数即达到最大值。</li>
<li>零空间（Null space），一些变换后落在零向量上的向量构成的空间。</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/08/AlgorithmNotes/" rel="next" title="算法和数据结构知识点整理，持续更新...">
                <i class="fa fa-chevron-left"></i> 算法和数据结构知识点整理，持续更新...
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/23/visual-information-theory/" rel="prev" title="看图理解信息理论中的“熵”、“交叉熵”等概念">
                看图理解信息理论中的“熵”、“交叉熵”等概念 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://ewa2xg.dm.files.1drv.com/y4mFMxhQ1DM81Jvak_RBJiGQ3w8LsLmDqb0ohVKkPYwEEraNIEfIiKXMg02UaLGvQErnG1rYTAIQeDIMzSmXnHjZ2UcGrK8wApxrjNxElJCL9BJOKRc9f-ciWgJJiML6e0UOtwWbNmlDOMjYq11-KUhdY9xXgnUqT2RcyElJoRIo0yuNmHDChUPkEcYBG_7BzrxyZIGr6pO2roys0Cg4n609w?width=1280&height=718&cropmode=none" alt="欢乐一只虾">
            
              <p class="site-author-name" itemprop="name">欢乐一只虾</p>
              <div class="site-description motion-element" itemprop="description">xia写的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#2022"><span class="nav-text">2022</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2022-01"><span class="nav-text">2022-01</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2022-01-22"><span class="nav-text">2022-01-22</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2022-01-05"><span class="nav-text">2022-01-05</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021"><span class="nav-text">2021</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-09"><span class="nav-text">2021-09</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-09-07"><span class="nav-text">2021-09-07</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-08"><span class="nav-text">2021-08</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-08-03"><span class="nav-text">2021-08-03</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-08-02"><span class="nav-text">2021-08-02</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-08-01"><span class="nav-text">2021-08-01</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-07"><span class="nav-text">2021-07</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-07-06"><span class="nav-text">2021-07-06</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-06"><span class="nav-text">2021-06</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-06-17"><span class="nav-text">2021-06-17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-06-10"><span class="nav-text">2021-06-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-06-09"><span class="nav-text">2021-06-09</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-05"><span class="nav-text">2021-05</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-05-12"><span class="nav-text">2021-05-12</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-05-11"><span class="nav-text">2021-05-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-05-10"><span class="nav-text">2021-05-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-05-08"><span class="nav-text">2021-05-08</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-04"><span class="nav-text">2021-04</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-04-23"><span class="nav-text">2021-04-23</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-04-08"><span class="nav-text">2021-04-08</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-04-07"><span class="nav-text">2021-04-07</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-03"><span class="nav-text">2021-03</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-31"><span class="nav-text">2021-03-31</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-29"><span class="nav-text">2021-03-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-25"><span class="nav-text">2021-03-25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-22"><span class="nav-text">2021-03-22</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-19"><span class="nav-text">2021-03-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-18"><span class="nav-text">2021-03-18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-16"><span class="nav-text">2021-03-16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-15"><span class="nav-text">2021-03-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-14"><span class="nav-text">2021-03-14</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-10"><span class="nav-text">2021-03-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-09"><span class="nav-text">2021-03-09</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-05"><span class="nav-text">2021-03-05</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-04"><span class="nav-text">2021-03-04</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-03-03"><span class="nav-text">2021-03-03</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-02"><span class="nav-text">2021-02</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-02-15"><span class="nav-text">2021-02-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-02-04"><span class="nav-text">2021-02-04</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-02-03"><span class="nav-text">2021-02-03</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2021-01"><span class="nav-text">2021-01</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2021-01-27"><span class="nav-text">2021-01-27</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-26"><span class="nav-text">2020-01-26</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-25"><span class="nav-text">2020-01-25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-07"><span class="nav-text">2020-01-07</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-04"><span class="nav-text">2020-01-04</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2020"><span class="nav-text">2020</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-12"><span class="nav-text">2020-12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-12-29"><span class="nav-text">2020-12-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-12-22"><span class="nav-text">2020-12-22</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-12-21"><span class="nav-text">2020-12-21</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-12-15"><span class="nav-text">2020-12-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-12-14"><span class="nav-text">2020-12-14</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-12-13"><span class="nav-text">2020-12-13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-12-11"><span class="nav-text">2020-12-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-12-02"><span class="nav-text">2020-12-02</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-11"><span class="nav-text">2020-11</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-11-26"><span class="nav-text">2020-11-26</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-11-19"><span class="nav-text">2020-11-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-11-13"><span class="nav-text">2020-11-13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-11-11"><span class="nav-text">2020-11-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-11-10"><span class="nav-text">2020-11-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-11-07"><span class="nav-text">2020-11-07</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-11-02"><span class="nav-text">2020-11-02</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-10"><span class="nav-text">2020-10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-10-31"><span class="nav-text">2020-10-31</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-10-24"><span class="nav-text">2020-10-24</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-10-14"><span class="nav-text">2020-10-14</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-10-13"><span class="nav-text">2020-10-13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-10-03"><span class="nav-text">2020-10-03</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-09"><span class="nav-text">2020-09</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-09-29"><span class="nav-text">2020-09-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-09-16"><span class="nav-text">2020-09-16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-09-10"><span class="nav-text">2020-09-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-09-08"><span class="nav-text">2020-09-08</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-09-07"><span class="nav-text">2020-09-07</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-09-04"><span class="nav-text">2020-09-04</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-09-01"><span class="nav-text">2020-09-01</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-08"><span class="nav-text">2020-08</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-19"><span class="nav-text">2020-08-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-18"><span class="nav-text">2020-08-18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-17"><span class="nav-text">2020-08-17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-14"><span class="nav-text">2020-08-14</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-13"><span class="nav-text">2020-08-13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-11"><span class="nav-text">2020-08-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-06"><span class="nav-text">2020-08-06</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-05"><span class="nav-text">2020-08-05</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-04"><span class="nav-text">2020-08-04</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-08-03"><span class="nav-text">2020-08-03</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-07"><span class="nav-text">2020-07</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-07-24："><span class="nav-text">2020-07-24：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-07-22"><span class="nav-text">2020-07-22:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-07-21"><span class="nav-text">2020-07-21:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-06"><span class="nav-text">2020-06</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-30"><span class="nav-text">2020-06-30</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-29"><span class="nav-text">2020-06-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-28"><span class="nav-text">2020-06-28</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-23"><span class="nav-text">2020-06-23</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-22"><span class="nav-text">2020-06-22</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-16"><span class="nav-text">2020-06-16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-15"><span class="nav-text">2020-06-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-11"><span class="nav-text">2020-06-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-10"><span class="nav-text">2020-06-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-09"><span class="nav-text">2020-06-09</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-03"><span class="nav-text">2020-06-03</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-02"><span class="nav-text">2020-06-02</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-06-01"><span class="nav-text">2020-06-01</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-05"><span class="nav-text">2020-05</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-29"><span class="nav-text">2020-05-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-28"><span class="nav-text">2020-05-28</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-27"><span class="nav-text">2020-05-27</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-25"><span class="nav-text">2020-05-25</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线性代数（花书）："><span class="nav-text">线性代数（花书）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-19"><span class="nav-text">2020-05-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-12"><span class="nav-text">2020-05-12</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-08"><span class="nav-text">2020-05-08</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-07"><span class="nav-text">2020-05-07</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-05-04"><span class="nav-text">2020-05-04</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-04"><span class="nav-text">2020-04</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-29"><span class="nav-text">2020-04-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-26"><span class="nav-text">2020-04-26</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-23"><span class="nav-text">2020-04-23</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-22"><span class="nav-text">2020-04-22</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-16"><span class="nav-text">2020-04-16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-15"><span class="nav-text">2020-04-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-09"><span class="nav-text">2020-04-09</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-08"><span class="nav-text">2020-04-08</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-07"><span class="nav-text">2020-04-07</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-04-03"><span class="nav-text">2020-04-03</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-03"><span class="nav-text">2020-03</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-03-25"><span class="nav-text">2020-03-25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-03-24"><span class="nav-text">2020-03-24</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-03-23"><span class="nav-text">2020-03-23</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-03-18"><span class="nav-text">2020-03-18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-03-17"><span class="nav-text">2020-03-17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-03-11"><span class="nav-text">2020-03-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-03-10"><span class="nav-text">2020-03-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-03-04"><span class="nav-text">2020-03-04</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-02"><span class="nav-text">2020-02</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-26"><span class="nav-text">2020-02-26</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-25"><span class="nav-text">2020-02-25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-23"><span class="nav-text">2020-02-23</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-22"><span class="nav-text">2020-02-22</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-21"><span class="nav-text">2020-02-21</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-20"><span class="nav-text">2020-02-20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-15"><span class="nav-text">2020-02-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-11"><span class="nav-text">2020-02-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-10"><span class="nav-text">2020-02-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-07"><span class="nav-text">2020-02-07</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-06"><span class="nav-text">2020-02-06</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-02-04"><span class="nav-text">2020-02-04</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2020-01"><span class="nav-text">2020-01</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-21"><span class="nav-text">2020-01-21</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-19"><span class="nav-text">2020-01-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-15"><span class="nav-text">2020-01-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-13"><span class="nav-text">2020-01-13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-09"><span class="nav-text">2020-01-09</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-08"><span class="nav-text">2020-01-08</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-07-1"><span class="nav-text">2020-01-07</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-06"><span class="nav-text">2020-01-06</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2020-01-03"><span class="nav-text">2020-01-03</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2019"><span class="nav-text">2019</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-12"><span class="nav-text">2019-12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-12-19"><span class="nav-text">2019-12-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-12-18"><span class="nav-text">2019-12-18</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-11"><span class="nav-text">2019-11</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-25"><span class="nav-text">2019-11-25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-21"><span class="nav-text">2019-11-21</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-20"><span class="nav-text">2019-11-20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-19"><span class="nav-text">2019-11-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-13"><span class="nav-text">2019-11-13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-12"><span class="nav-text">2019-11-12</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-11-11"><span class="nav-text">2019-11-11</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-10"><span class="nav-text">2019-10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-10-31"><span class="nav-text">2019-10-31</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-10-27"><span class="nav-text">2019-10-27</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-10-17"><span class="nav-text">2019-10-17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-10-10"><span class="nav-text">2019-10-10</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-09"><span class="nav-text">2019-09</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-09-29"><span class="nav-text">2019-09-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-09-27"><span class="nav-text">2019-09-27</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-09-26"><span class="nav-text">2019-09-26</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-09-25"><span class="nav-text">2019-09-25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-09-24"><span class="nav-text">2019-09-24</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-09-23"><span class="nav-text">2019-09-23</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-09-10"><span class="nav-text">2019-09-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-09-09"><span class="nav-text">2019-09-09</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-08"><span class="nav-text">2019-08</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-08-06"><span class="nav-text">2019-08-06</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-08-02"><span class="nav-text">2019-08-02</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-07"><span class="nav-text">2019-07</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-30"><span class="nav-text">2019-07-30</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-28"><span class="nav-text">2019-07-28</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-24"><span class="nav-text">2019-07-24</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-18"><span class="nav-text">2019-07-18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-12"><span class="nav-text">2019-07-12</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-07"><span class="nav-text">2019-07-07</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-05"><span class="nav-text">2019-07-05</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-04"><span class="nav-text">2019-07-04</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-03"><span class="nav-text">2019-07-03</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-07-02"><span class="nav-text">2019-07-02</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-06"><span class="nav-text">2019-06</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-06-28"><span class="nav-text">2019-06-28</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-06-27"><span class="nav-text">2019-06-27</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-06-24"><span class="nav-text">2019-06-24</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-06-18"><span class="nav-text">2019-06-18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-06-13"><span class="nav-text">2019-06-13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-06-11"><span class="nav-text">2019-06-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-06-10"><span class="nav-text">2019-06-10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-06-04"><span class="nav-text">2019-06-04</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-05"><span class="nav-text">2019-05</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-05-31"><span class="nav-text">2019-05-31</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-05-29"><span class="nav-text">2019-05-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-05-29-1"><span class="nav-text">2019-05-29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-05-21"><span class="nav-text">2019-05-21</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-05-15"><span class="nav-text">2019-05-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-05-14"><span class="nav-text">2019-05-14</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-05-09"><span class="nav-text">2019-05-09</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-05-05"><span class="nav-text">2019-05-05</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-04"><span class="nav-text">2019-04</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-25"><span class="nav-text">2019-04-25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-19"><span class="nav-text">2019-04-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-17"><span class="nav-text">2019-04-17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-15"><span class="nav-text">2019-04-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-11"><span class="nav-text">2019-04-11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-09"><span class="nav-text">2019-04-09</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-04"><span class="nav-text">2019-04-04</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-03"><span class="nav-text">2019-04-03</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-04-02"><span class="nav-text">2019-04-02</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-03"><span class="nav-text">2019-03</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-03-30"><span class="nav-text">2019-03-30</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-03-28"><span class="nav-text">2019-03-28</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-03-26"><span class="nav-text">2019-03-26</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-03-21"><span class="nav-text">2019-03-21</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-03-19"><span class="nav-text">2019-03-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-03-06"><span class="nav-text">2019-03-06</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-03-05"><span class="nav-text">2019-03-05</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-03-04"><span class="nav-text">2019-03-04</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019-02"><span class="nav-text">2019-02</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-02-28"><span class="nav-text">2019-02-28</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-02-19"><span class="nav-text">2019-02-19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-02-17"><span class="nav-text">2019-02-17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-02-15"><span class="nav-text">2019-02-15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-02-14"><span class="nav-text">2019-02-14</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2019-02-13"><span class="nav-text">2019-02-13</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">欢乐一只虾</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">107k</span>
  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a></div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  













  



  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  
  <script src="/js/js.cookie.js?v=7.1.2"></script>
  <script src="/js/scroll-cookie.js?v=7.1.2"></script>


  

  
  
  

  

  
  
  


  


  


  




  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

  

  

  

  

  

  

  

</body>
</html>
